initSidebarItems({"enum":[["AttributeFlags","An attribute selector can have 's' or 'i' as flags, or no flags at all."],["Combinator",""],["Component","A CSS simple selector or combinator. We store both in the same enum for optimal packing and cache performance, see [1]."],["OptionalQName",""],["QNamePrefix",""],["SelectorParseErrorKind",""],["SimpleSelectorParseResult",""]],"fn":[["collect_ancestor_hashes",""],["display_to_css_identifier","Serialize the output of Display as a CSS identifier"],["is_css2_pseudo_element","Returns whether the name corresponds to a CSS2 pseudo-element that can be specified with the single colon syntax (in addition to the double-colon syntax, which can be used for all pseudo-elements)."],["namespace_empty_string",""],["parse_attribute_flags",""],["parse_attribute_selector",""],["parse_compound_selector","simple_selector_sequence : [ type_selector | universal ] [ HASH | class | attrib | pseudo | negation ]* | [ HASH | class | attrib | pseudo | negation ]+"],["parse_compound_selector_list","Parse a comma separated list of compound selectors."],["parse_functional_pseudo_class",""],["parse_inner_compound_selector","Parses one compound selector suitable for nested stuff like :-moz-any, etc."],["parse_is_or_where",""],["parse_negation","Level 3: Parse one simple_selector.  (Though we might insert a second implied \"|*\" type selector.)"],["parse_nth_pseudo_class",""],["parse_one_simple_selector","Parse a simple selector other than a type selector."],["parse_qualified_name","`Err(())``Ok(None(token))``input``Ok(Some(namespace, local_name))``None``*`"],["parse_selector","Build up a Selector. selector : simple_selector_sequence [ combinator simple_selector_sequence ]* ;"],["parse_simple_pseudo_class",""],["parse_type_selector","`Err(())``Ok(false)``input``Ok(true)``*|*``*|E``ns|*``|E``ns|E`"],["serialize_selector_list",""],["to_ascii_lowercase","Returns a Cow::Borrowed if `s` is already ASCII lowercase, and a Cow::Owned if `s` had to be converted into ASCII lowercase."]],"struct":[["AncestorHashes","Ancestor hashes for the bloom filter. We precompute these and store them inline with selectors to optimize cache performance during matching. This matters a lot."],["AncestorIter","An iterator over all simple selectors belonging to ancestors."],["LocalName",""],["Selector","A Selector stores a sequence of simple selectors and combinators. The iterator classes allow callers to iterate at either the raw sequence level or at the level of sequences of simple selectors separated by combinators. Most callers want the higher-level iterator."],["SelectorIter",""],["SelectorList",""],["SelectorParsingState","Flags that indicate at which point of parsing a selector are we."]],"trait":[["NonTSPseudoClass","A trait that represents a pseudo-class."],["Parser",""],["PseudoElement","A trait that represents a pseudo-element."],["SelectorImpl","This trait allows to define the parser implementation in regards of pseudo-classes/elements"]],"type":[["SelectorParseError",""]]});