<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `OwnedSlice` struct in crate `style`."><meta name="keywords" content="rust, rustlang, rust-lang, OwnedSlice"><title>style::OwnedSlice - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../style/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Struct OwnedSlice</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#fields">Fields</a><div class="sidebar-links"><a href="#structfield._phantom">_phantom</a><a href="#structfield.len">len</a><a href="#structfield.ptr">ptr</a></div><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.from_slice">from_slice</a><a href="#method.into_box">into_box</a><a href="#method.into_iter">into_iter</a><a href="#method.into_vec">into_vec</a></div><a class="sidebar-title" href="#deref-methods">Methods from Deref&lt;Target=[T]&gt;</a><div class="sidebar-links"><a href="#method.align_to">align_to</a><a href="#method.align_to_mut">align_to_mut</a><a href="#method.as_mut_ptr">as_mut_ptr</a><a href="#method.as_mut_ptr_range">as_mut_ptr_range</a><a href="#method.as_ptr">as_ptr</a><a href="#method.as_ptr_range">as_ptr_range</a><a href="#method.binary_search">binary_search</a><a href="#method.binary_search_by">binary_search_by</a><a href="#method.binary_search_by_key">binary_search_by_key</a><a href="#method.chunks">chunks</a><a href="#method.chunks_exact">chunks_exact</a><a href="#method.chunks_exact_mut">chunks_exact_mut</a><a href="#method.chunks_mut">chunks_mut</a><a href="#method.clone_from_slice">clone_from_slice</a><a href="#method.concat">concat</a><a href="#method.connect">connect</a><a href="#method.contains">contains</a><a href="#method.copy_from_slice">copy_from_slice</a><a href="#method.copy_within">copy_within</a><a href="#method.ends_with">ends_with</a><a href="#method.eq_ignore_ascii_case">eq_ignore_ascii_case</a><a href="#method.fill">fill</a><a href="#method.first">first</a><a href="#method.first_mut">first_mut</a><a href="#method.get">get</a><a href="#method.get_mut">get_mut</a><a href="#method.get_unchecked">get_unchecked</a><a href="#method.get_unchecked_mut">get_unchecked_mut</a><a href="#method.is_ascii">is_ascii</a><a href="#method.is_empty">is_empty</a><a href="#method.is_sorted">is_sorted</a><a href="#method.is_sorted_by">is_sorted_by</a><a href="#method.is_sorted_by_key">is_sorted_by_key</a><a href="#method.iter">iter</a><a href="#method.iter_mut">iter_mut</a><a href="#method.join">join</a><a href="#method.last">last</a><a href="#method.last_mut">last_mut</a><a href="#method.len">len</a><a href="#method.make_ascii_lowercase">make_ascii_lowercase</a><a href="#method.make_ascii_uppercase">make_ascii_uppercase</a><a href="#method.partition_at_index">partition_at_index</a><a href="#method.partition_at_index_by">partition_at_index_by</a><a href="#method.partition_at_index_by_key">partition_at_index_by_key</a><a href="#method.partition_dedup">partition_dedup</a><a href="#method.partition_dedup_by">partition_dedup_by</a><a href="#method.partition_dedup_by_key">partition_dedup_by_key</a><a href="#method.partition_point">partition_point</a><a href="#method.rchunks">rchunks</a><a href="#method.rchunks_exact">rchunks_exact</a><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a><a href="#method.rchunks_mut">rchunks_mut</a><a href="#method.repeat">repeat</a><a href="#method.reverse">reverse</a><a href="#method.rotate_left">rotate_left</a><a href="#method.rotate_right">rotate_right</a><a href="#method.rsplit">rsplit</a><a href="#method.rsplit_mut">rsplit_mut</a><a href="#method.rsplitn">rsplitn</a><a href="#method.rsplitn_mut">rsplitn_mut</a><a href="#method.sort">sort</a><a href="#method.sort_by">sort_by</a><a href="#method.sort_by_cached_key">sort_by_cached_key</a><a href="#method.sort_by_key">sort_by_key</a><a href="#method.sort_unstable">sort_unstable</a><a href="#method.sort_unstable_by">sort_unstable_by</a><a href="#method.sort_unstable_by_key">sort_unstable_by_key</a><a href="#method.split">split</a><a href="#method.split_at">split_at</a><a href="#method.split_at_mut">split_at_mut</a><a href="#method.split_first">split_first</a><a href="#method.split_first_mut">split_first_mut</a><a href="#method.split_inclusive">split_inclusive</a><a href="#method.split_inclusive_mut">split_inclusive_mut</a><a href="#method.split_last">split_last</a><a href="#method.split_last_mut">split_last_mut</a><a href="#method.split_mut">split_mut</a><a href="#method.splitn">splitn</a><a href="#method.splitn_mut">splitn_mut</a><a href="#method.starts_with">starts_with</a><a href="#method.strip_prefix">strip_prefix</a><a href="#method.strip_suffix">strip_suffix</a><a href="#method.swap">swap</a><a href="#method.swap_with_slice">swap_with_slice</a><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a><a href="#method.to_vec">to_vec</a><a href="#method.windows">windows</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Debug">Debug</a><a href="#impl-Default">Default</a><a href="#impl-Deref">Deref</a><a href="#impl-DerefMut">DerefMut</a><a href="#impl-Deserialize%3C%27de%3E">Deserialize&lt;&#39;de&gt;</a><a href="#impl-Drop">Drop</a><a href="#impl-Eq">Eq</a><a href="#impl-From%3CBox%3C%5BT%5D%3E%3E">From&lt;Box&lt;[T]&gt;&gt;</a><a href="#impl-From%3COwnedSlice%3CGenericBoxShadow%3CGenericColor%3CRGBA%3E%2C%20CSSPixelLength%2C%20NonNegative%3CCSSPixelLength%3E%2C%20CSSPixelLength%3E%3E%3E">From&lt;OwnedSlice&lt;GenericBoxShadow&lt;GenericColor&lt;RGBA&gt;, CSSPixelLength, NonNegative&lt;CSSPixelLength&gt;, CSSPixelLength&gt;&gt;&gt;</a><a href="#impl-From%3COwnedSlice%3CGenericFilter%3CAngle%2C%20NonNegative%3Cf32%3E%2C%20ZeroToOne%3Cf32%3E%2C%20NonNegative%3CCSSPixelLength%3E%2C%20Impossible%2C%20Impossible%3E%3E%3E">From&lt;OwnedSlice&lt;GenericFilter&lt;Angle, NonNegative&lt;f32&gt;, ZeroToOne&lt;f32&gt;, NonNegative&lt;CSSPixelLength&gt;, Impossible, Impossible&gt;&gt;&gt;</a><a href="#impl-From%3CVec%3CT%3E%3E">From&lt;Vec&lt;T&gt;&gt;</a><a href="#impl-FromIterator%3CT%3E">FromIterator&lt;T&gt;</a><a href="#impl-ListAnimation%3CT%3E">ListAnimation&lt;T&gt;</a><a href="#impl-MallocShallowSizeOf">MallocShallowSizeOf</a><a href="#impl-MallocSizeOf">MallocSizeOf</a><a href="#impl-PartialEq%3COwnedSlice%3CT%3E%3E">PartialEq&lt;OwnedSlice&lt;T&gt;&gt;</a><a href="#impl-Send">Send</a><a href="#impl-Serialize">Serialize</a><a href="#impl-SpecifiedValueInfo">SpecifiedValueInfo</a><a href="#impl-Sync">Sync</a><a href="#impl-ToAnimatedValue">ToAnimatedValue</a><a href="#impl-ToAnimatedZero">ToAnimatedZero</a><a href="#impl-ToComputedValue">ToComputedValue</a><a href="#impl-ToResolvedValue">ToResolvedValue</a><a href="#impl-ToShmem">ToShmem</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-DeserializeOwned">DeserializeOwned</a><a href="#impl-Equivalent%3CK%3E">Equivalent&lt;K&gt;</a><a href="#impl-Erased">Erased</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-MaybeBoxed%3CBox%3CT%3E%3E">MaybeBoxed&lt;Box&lt;T&gt;&gt;</a><a href="#impl-MaybeBoxed%3CT%3E">MaybeBoxed&lt;T&gt;</a><a href="#impl-Pointable">Pointable</a><a href="#impl-Same%3CT%3E">Same&lt;T&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><p class='location'><a href='index.html'>style</a></p><script>window.sidebarCurrent = {name: 'OwnedSlice', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/style_traits/owned_slice.rs.html#31-35' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='index.html'>style</a>::<wbr><a class="struct" href=''>OwnedSlice</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'><span class="docblock attributes top-attr">#[repr(C)]</span>pub struct OwnedSlice&lt;T&gt; {
    ptr: <a class="struct" href="../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;T&gt;,
    len: <a class="primitive" href="../std/primitive.usize.html">usize</a>,
    _phantom: <a class="struct" href="../core/marker/struct.PhantomData.html" title="struct core::marker::PhantomData">PhantomData</a>&lt;T&gt;,
}</pre></div><div class='docblock'><p>A struct that basically replaces a <code>Box&lt;[T]&gt;</code>, but which cbindgen can
understand.</p>
<p>We could rely on the struct layout of <code>Box&lt;[T]&gt;</code> per:</p>
<p>https://github.com/rust-lang/unsafe-code-guidelines/blob/master/reference/src/layout/pointers.md</p>
<p>But handling fat pointers with cbindgen both in structs and argument
positions more generally is a bit tricky.</p>
<p>cbindgen:derive-eq=false
cbindgen:derive-neq=false</p>
</div><h2 id='fields' class='fields small-section-header'>
                       Fields<a href='#fields' class='anchor'></a></h2><span id="structfield.ptr" class="structfield small-section-header"><a href="#structfield.ptr" class="anchor field"></a><code>ptr: <a class="struct" href="../core/ptr/non_null/struct.NonNull.html" title="struct core::ptr::non_null::NonNull">NonNull</a>&lt;T&gt;</code></span><span id="structfield.len" class="structfield small-section-header"><a href="#structfield.len" class="anchor field"></a><code>len: <a class="primitive" href="../std/primitive.usize.html">usize</a></code></span><span id="structfield._phantom" class="structfield small-section-header"><a href="#structfield._phantom" class="anchor field"></a><code>_phantom: <a class="struct" href="../core/marker/struct.PhantomData.html" title="struct core::marker::PhantomData">PhantomData</a>&lt;T&gt;</code></span><h2 id='implementations' class='small-section-header'>Implementations<a href='#implementations' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#81-110' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into_box' class="method"><code>pub fn <a href='#method.into_box' class='fnname'>into_box</a>(self) -&gt; <a class="struct" href="../alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#84-86' title='goto source code'>[src]</a></h4><div class='docblock'><p>Convert the OwnedSlice into a boxed slice.</p>
</div><h4 id='method.into_vec' class="method"><code>pub fn <a href='#method.into_vec' class='fnname'>into_vec</a>(self) -&gt; <a class="struct" href="../alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#90-94' title='goto source code'>[src]</a></h4><div class='docblock'><p>Convert the OwnedSlice into a Vec.</p>
</div><h4 id='method.into_iter' class="method"><code>pub fn <a href='#method.into_iter' class='fnname'>into_iter</a>(self) -&gt; impl <a class="trait" href="../core/iter/traits/exact_size/trait.ExactSizeIterator.html" title="trait core::iter::traits::exact_size::ExactSizeIterator">ExactSizeIterator</a> + <a class="trait" href="../core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = T&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#98-100' title='goto source code'>[src]</a></h4><div class='docblock'><p>Iterate over all the elements in the slice taking ownership of them.</p>
</div><h4 id='method.from_slice' class="method"><code>pub fn <a href='#method.from_slice' class='fnname'>from_slice</a>(s: <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>) -&gt; <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#104-109' title='goto source code'>[src]</a></h4><div class='docblock'><p>Convert the regular slice into an owned slice.</p>
</div></div><h2 id='deref-methods' class='small-section-header'>Methods from <a class="trait" href="../core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;<a href='#deref-methods' class='anchor'></a></h2><div class='impl-items'><h4 id='method.len' class="method"><code>pub const fn <a href='#method.len' class='fnname'>len</a>(&amp;self) -&gt; <a class="primitive" href="../std/primitive.usize.html">usize</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#72-74' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the number of elements in the slice.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">len</span>(), <span class="number">3</span>);</pre></div>
</div><h4 id='method.is_empty' class="method"><code>pub const fn <a href='#method.is_empty' class='fnname'>is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#87-89' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if the slice has a length of 0.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">a</span>.<span class="ident">is_empty</span>());</pre></div>
</div><h4 id='method.first' class="method"><code>pub fn <a href='#method.first' class='fnname'>first</a>(&amp;self) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#104-106' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the first element of the slice, or <code>None</code> if it is empty.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">10</span>), <span class="ident">v</span>.<span class="ident">first</span>());

<span class="kw">let</span> <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">i32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">w</span>.<span class="ident">first</span>());</pre></div>
</div><h4 id='method.first_mut' class="method"><code>pub fn <a href='#method.first_mut' class='fnname'>first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#122-124' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a mutable pointer to the first element of the slice, or <code>None</code> if it is empty.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">first</span>) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">first_mut</span>() {
    <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="number">5</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]);</pre></div>
</div><h4 id='method.split_first' class="method"><code>pub fn <a href='#method.split_first' class='fnname'>split_first</a>(&amp;self) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.reference.html">&amp;</a>T, <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a>&gt;</code><span class='since' title='Stable since Rust version 1.5.0'>1.5.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#140-142' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the first and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">first</span>, <span class="ident">elements</span>)) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_first</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">first</span>, <span class="kw-2">&amp;</span><span class="number">0</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">elements</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>]);
}</pre></div>
</div><h4 id='method.split_first_mut' class="method"><code>pub fn <a href='#method.split_first_mut' class='fnname'>split_first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a>&gt;</code><span class='since' title='Stable since Rust version 1.5.0'>1.5.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#160-162' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the first and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">first</span>, <span class="ident">elements</span>)) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_first_mut</span>() {
    <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="number">3</span>;
    <span class="ident">elements</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">4</span>;
    <span class="ident">elements</span>[<span class="number">1</span>] <span class="op">=</span> <span class="number">5</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</pre></div>
</div><h4 id='method.split_last' class="method"><code>pub fn <a href='#method.split_last' class='fnname'>split_last</a>(&amp;self) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.reference.html">&amp;</a>T, <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a>&gt;</code><span class='since' title='Stable since Rust version 1.5.0'>1.5.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#178-180' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the last and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">last</span>, <span class="ident">elements</span>)) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_last</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">last</span>, <span class="kw-2">&amp;</span><span class="number">2</span>);
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">elements</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>]);
}</pre></div>
</div><h4 id='method.split_last_mut' class="method"><code>pub fn <a href='#method.split_last_mut' class='fnname'>split_last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a>&gt;</code><span class='since' title='Stable since Rust version 1.5.0'>1.5.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#198-200' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the last and all the rest of the elements of the slice, or <code>None</code> if it is empty.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">last</span>, <span class="ident">elements</span>)) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">split_last_mut</span>() {
    <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="number">3</span>;
    <span class="ident">elements</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">4</span>;
    <span class="ident">elements</span>[<span class="number">1</span>] <span class="op">=</span> <span class="number">5</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>]);</pre></div>
</div><h4 id='method.last' class="method"><code>pub fn <a href='#method.last' class='fnname'>last</a>(&amp;self) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#215-217' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns the last element of the slice, or <code>None</code> if it is empty.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">30</span>), <span class="ident">v</span>.<span class="ident">last</span>());

<span class="kw">let</span> <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">i32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">w</span>.<span class="ident">last</span>());</pre></div>
</div><h4 id='method.last_mut' class="method"><code>pub fn <a href='#method.last_mut' class='fnname'>last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#233-235' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a mutable pointer to the last item in the slice.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">last</span>) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">last_mut</span>() {
    <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="number">10</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>]);</pre></div>
</div><h4 id='method.get' class="method"><code>pub fn <a href='#method.get' class='fnname'>get</a>&lt;I&gt;(&amp;self, index: I) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="../core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;&gt;::<a class="type" href="../core/slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#256-261' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a reference to an element or subslice depending on the type of
index.</p>
<ul>
<li>If given a position, returns a reference to the element at that
position or <code>None</code> if out of bounds.</li>
<li>If given a range, returns the subslice corresponding to that range,
or <code>None</code> if out of bounds.</li>
</ul>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">40</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>][..]), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span>..<span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">3</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">0</span>..<span class="number">4</span>));</pre></div>
</div><h4 id='method.get_mut' class="method"><code>pub fn <a href='#method.get_mut' class='fnname'>get_mut</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: I<br>) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut &lt;I as <a class="trait" href="../core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;&gt;::<a class="type" href="../core/slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#280-285' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a mutable reference to an element or subslice depending on the
type of index (see <a href="#method.get"><code>get</code></a>) or <code>None</code> if the index is out of bounds.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];

<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">elem</span>) <span class="op">=</span> <span class="ident">x</span>.<span class="ident">get_mut</span>(<span class="number">1</span>) {
    <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">=</span> <span class="number">42</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">42</span>, <span class="number">2</span>]);</pre></div>
</div><h4 id='method.get_unchecked' class="method"><code>pub unsafe fn <a href='#method.get_unchecked' class='fnname'>get_unchecked</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: I<br>) -&gt; &amp;&lt;I as <a class="trait" href="../core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;&gt;::<a class="type" href="../core/slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#309-317' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a reference to an element or subslice, without doing bounds
checking.</p>
<p>This is generally not recommended, use with caution!
Calling this method with an out-of-bounds index is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em>
even if the resulting reference is not used.
For a safe alternative see <a href="#method.get"><code>get</code></a>.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];

<span class="kw">unsafe</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">get_unchecked</span>(<span class="number">1</span>), <span class="kw-2">&amp;</span><span class="number">2</span>);
}</pre></div>
</div><h4 id='method.get_unchecked_mut' class="method"><code>pub unsafe fn <a href='#method.get_unchecked_mut' class='fnname'>get_unchecked_mut</a>&lt;I&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: I<br>) -&gt; &amp;mut &lt;I as <a class="trait" href="../core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;&gt;::<a class="type" href="../core/slice/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::SliceIndex::Output">Output</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../core/slice/trait.SliceIndex.html" title="trait core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#343-351' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a mutable reference to an element or subslice, without doing
bounds checking.</p>
<p>This is generally not recommended, use with caution!
Calling this method with an out-of-bounds index is <em><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behavior</a></em>
even if the resulting reference is not used.
For a safe alternative see <a href="#method.get_mut"><code>get_mut</code></a>.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];

<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">elem</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">1</span>);
    <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">=</span> <span class="number">13</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">13</span>, <span class="number">4</span>]);</pre></div>
</div><h4 id='method.as_ptr' class="method"><code>pub const fn <a href='#method.as_ptr' class='fnname'>as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="../std/primitive.pointer.html">*const T</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#382-384' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a raw pointer to the slice's buffer.</p>
<p>The caller must ensure that the slice outlives the pointer this
function returns, or else it will end up pointing to garbage.</p>
<p>The caller must also ensure that the memory the pointer (non-transitively) points to
is never written to (except inside an <code>UnsafeCell</code>) using this pointer or any pointer
derived from it. If you need to mutate the contents of the slice, use <a href="#method.as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<p>Modifying the container referenced by this slice may cause its buffer
to be reallocated, which would also make any pointers to it invalid.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">x_ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">x</span>.<span class="ident">len</span>() {
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">get_unchecked</span>(<span class="ident">i</span>), <span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">x_ptr</span>.<span class="ident">add</span>(<span class="ident">i</span>));
    }
}</pre></div>
</div><h4 id='method.as_mut_ptr' class="method"><code>pub fn <a href='#method.as_mut_ptr' class='fnname'>as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="../std/primitive.pointer.html">*mut T</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#409-411' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an unsafe mutable pointer to the slice's buffer.</p>
<p>The caller must ensure that the slice outlives the pointer this
function returns, or else it will end up pointing to garbage.</p>
<p>Modifying the container referenced by this slice may cause its buffer
to be reallocated, which would also make any pointers to it invalid.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];
<span class="kw">let</span> <span class="ident">x_ptr</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">as_mut_ptr</span>();

<span class="kw">unsafe</span> {
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">x</span>.<span class="ident">len</span>() {
        <span class="kw-2">*</span><span class="ident">x_ptr</span>.<span class="ident">add</span>(<span class="ident">i</span>) <span class="op">+=</span> <span class="number">2</span>;
    }
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]);</pre></div>
</div><h4 id='method.as_ptr_range' class="method"><code>pub fn <a href='#method.as_ptr_range' class='fnname'>as_ptr_range</a>(&amp;self) -&gt; <a class="struct" href="../core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="../std/primitive.pointer.html">*const T</a>&gt;</code><a class='srclink' href='../src/core/slice/mod.rs.html#445-466' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_range</code>)</div></div><div class='docblock'><p>Returns the two raw pointers spanning the slice.</p>
<p>The returned range is half-open, which means that the end pointer
points <em>one past</em> the last element of the slice. This way, an empty
slice is represented by two equal pointers, and the difference between
the two pointers represents the size of the slice.</p>
<p>See <a href="#method.as_ptr"><code>as_ptr</code></a> for warnings on using these pointers. The end pointer
requires extra caution, as it does not point to a valid element in the
slice.</p>
<p>This function is useful for interacting with foreign interfaces which
use two pointers to refer to a range of elements in memory, as is
common in C++.</p>
<p>It can also be useful to check if a pointer to an element refers to an
element of this slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_ptr_range</span>)]</span>

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">a</span>[<span class="number">1</span>] <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">_</span>;
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">5</span> <span class="kw">as</span> <span class="kw-2">*</span><span class="kw">const</span> <span class="kw">_</span>;

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">as_ptr_range</span>().<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">x</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">a</span>.<span class="ident">as_ptr_range</span>().<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">y</span>));</pre></div>
</div><h4 id='method.as_mut_ptr_range' class="method"><code>pub fn <a href='#method.as_mut_ptr_range' class='fnname'>as_mut_ptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="../core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="../std/primitive.pointer.html">*mut T</a>&gt;</code><a class='srclink' href='../src/core/slice/mod.rs.html#486-491' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_ptr_range</code>)</div></div><div class='docblock'><p>Returns the two unsafe mutable pointers spanning the slice.</p>
<p>The returned range is half-open, which means that the end pointer
points <em>one past</em> the last element of the slice. This way, an empty
slice is represented by two equal pointers, and the difference between
the two pointers represents the size of the slice.</p>
<p>See <a href="#method.as_mut_ptr"><code>as_mut_ptr</code></a> for warnings on using these pointers. The end
pointer requires extra caution, as it does not point to a valid element
in the slice.</p>
<p>This function is useful for interacting with foreign interfaces which
use two pointers to refer to a range of elements in memory, as is
common in C++.</p>
</div><h4 id='method.swap' class="method"><code>pub fn <a href='#method.swap' class='fnname'>swap</a>(&amp;mut self, a: <a class="primitive" href="../std/primitive.usize.html">usize</a>, b: <a class="primitive" href="../std/primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#513-521' title='goto source code'>[src]</a></h4><div class='docblock'><p>Swaps two elements in the slice.</p>
<h1 id="arguments" class="section-header"><a href="#arguments">Arguments</a></h1>
<ul>
<li>a - The index of the first element</li>
<li>b - The index of the second element</li>
</ul>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>];
<span class="ident">v</span>.<span class="ident">swap</span>(<span class="number">1</span>, <span class="number">3</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;b&quot;</span>]);</pre></div>
</div><h4 id='method.reverse' class="method"><code>pub fn <a href='#method.reverse' class='fnname'>reverse</a>(&amp;mut self)</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#534-594' title='goto source code'>[src]</a></h4><div class='docblock'><p>Reverses the order of elements in the slice, in place.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">v</span>.<span class="ident">reverse</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.iter' class="method"><code>pub fn <a href='#method.iter' class='fnname'>iter</a>(&amp;self) -&gt; <a class="struct" href="../core/slice/struct.Iter.html" title="struct core::slice::Iter">Iter</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#611-624' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over the slice.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iterator</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">iter</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">4</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iterator</span>.<span class="ident">next</span>(), <span class="prelude-val">None</span>);</pre></div>
</div><h4 id='method.iter_mut' class="method"><code>pub fn <a href='#method.iter_mut' class='fnname'>iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../core/slice/struct.IterMut.html" title="struct core::slice::IterMut">IterMut</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#639-652' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator that allows modifying each value.</p>
<h1 id="examples-19" class="section-header"><a href="#examples-19">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];
<span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="ident">x</span>.<span class="ident">iter_mut</span>() {
    <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">+=</span> <span class="number">2</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]);</pre></div>
</div><h4 id='method.windows' class="method"><code>pub fn <a href='#method.windows' class='fnname'>windows</a>(&amp;self, size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.Windows.html" title="struct core::slice::Windows">Windows</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#682-685' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over all contiguous windows of length
<code>size</code>. The windows overlap. If the slice is shorter than
<code>size</code>, the iterator returns no values.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>Panics if <code>size</code> is 0.</p>
<h1 id="examples-20" class="section-header"><a href="#examples-20">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="string">&#39;r&#39;</span>, <span class="string">&#39;u&#39;</span>, <span class="string">&#39;s&#39;</span>, <span class="string">&#39;t&#39;</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">windows</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;r&#39;</span>, <span class="string">&#39;u&#39;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;u&#39;</span>, <span class="string">&#39;s&#39;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;s&#39;</span>, <span class="string">&#39;t&#39;</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If the slice is shorter than <code>size</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="string">&#39;f&#39;</span>, <span class="string">&#39;o&#39;</span>, <span class="string">&#39;o&#39;</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">windows</span>(<span class="number">4</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.chunks' class="method"><code>pub fn <a href='#method.chunks' class='fnname'>chunks</a>(&amp;self, chunk_size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.Chunks.html" title="struct core::slice::Chunks">Chunks</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#716-719' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the
beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the
slice, then the last chunk will not have length <code>chunk_size</code>.</p>
<p>See <a href="#method.chunks_exact"><code>chunks_exact</code></a> for a variant of this iterator that returns chunks of always exactly
<code>chunk_size</code> elements, and <a href="#method.rchunks"><code>rchunks</code></a> for the same iterator but starting at the end of the
slice.</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-21" class="section-header"><a href="#examples-21">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="string">&#39;l&#39;</span>, <span class="string">&#39;o&#39;</span>, <span class="string">&#39;r&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;m&#39;</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">chunks</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;l&#39;</span>, <span class="string">&#39;o&#39;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;r&#39;</span>, <span class="string">&#39;e&#39;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;m&#39;</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.chunks_mut' class="method"><code>pub fn <a href='#method.chunks_mut' class='fnname'>chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.ChunksMut.html" title="struct core::slice::ChunksMut">ChunksMut</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#754-757' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the
beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the
length of the slice, then the last chunk will not have length <code>chunk_size</code>.</p>
<p>See <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for a variant of this iterator that returns chunks of always
exactly <code>chunk_size</code> elements, and <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for the same iterator but starting at
the end of the slice.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-22" class="section-header"><a href="#examples-22">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">1</span>;

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">chunks_mut</span>(<span class="number">2</span>) {
    <span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="ident">chunk</span>.<span class="ident">iter_mut</span>() {
        <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">+=</span> <span class="ident">count</span>;
    }
    <span class="ident">count</span> <span class="op">+=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]);</pre></div>
</div><h4 id='method.chunks_exact' class="method"><code>pub fn <a href='#method.chunks_exact' class='fnname'>chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.ChunksExact.html" title="struct core::slice::ChunksExact">ChunksExact</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.31.0'>1.31.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#791-797' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the
beginning of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the
slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be retrieved
from the <code>remainder</code> function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the
resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p>
<p>See <a href="#method.chunks"><code>chunks</code></a> for a variant of this iterator that also returns the remainder as a smaller
chunk, and <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for the same iterator but starting at the end of the slice.</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-23" class="section-header"><a href="#examples-23">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="string">&#39;l&#39;</span>, <span class="string">&#39;o&#39;</span>, <span class="string">&#39;r&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;m&#39;</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">chunks_exact</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;l&#39;</span>, <span class="string">&#39;o&#39;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;r&#39;</span>, <span class="string">&#39;e&#39;</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;m&#39;</span>]);</pre></div>
</div><h4 id='method.chunks_exact_mut' class="method"><code>pub fn <a href='#method.chunks_exact_mut' class='fnname'>chunks_exact_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.ChunksExactMut.html" title="struct core::slice::ChunksExactMut">ChunksExactMut</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.31.0'>1.31.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#836-842' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the
beginning of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the
length of the slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be
retrieved from the <code>into_remainder</code> function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the
resulting code better than in the case of <a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p>
<p>See <a href="#method.chunks_mut"><code>chunks_mut</code></a> for a variant of this iterator that also returns the remainder as a
smaller chunk, and <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for the same iterator but starting at the end of
the slice.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-24" class="section-header"><a href="#examples-24">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">1</span>;

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">chunks_exact_mut</span>(<span class="number">2</span>) {
    <span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="ident">chunk</span>.<span class="ident">iter_mut</span>() {
        <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">+=</span> <span class="ident">count</span>;
    }
    <span class="ident">count</span> <span class="op">+=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>]);</pre></div>
</div><h4 id='method.rchunks' class="method"><code>pub fn <a href='#method.rchunks' class='fnname'>rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.RChunks.html" title="struct core::slice::RChunks">RChunks</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.31.0'>1.31.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#873-876' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end
of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the
slice, then the last chunk will not have length <code>chunk_size</code>.</p>
<p>See <a href="#method.rchunks_exact"><code>rchunks_exact</code></a> for a variant of this iterator that returns chunks of always exactly
<code>chunk_size</code> elements, and <a href="#method.chunks"><code>chunks</code></a> for the same iterator but starting at the beginning
of the slice.</p>
<h1 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-25" class="section-header"><a href="#examples-25">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="string">&#39;l&#39;</span>, <span class="string">&#39;o&#39;</span>, <span class="string">&#39;r&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;m&#39;</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">rchunks</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;e&#39;</span>, <span class="string">&#39;m&#39;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;o&#39;</span>, <span class="string">&#39;r&#39;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;l&#39;</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.rchunks_mut' class="method"><code>pub fn <a href='#method.rchunks_mut' class='fnname'>rchunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.RChunksMut.html" title="struct core::slice::RChunksMut">RChunksMut</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.31.0'>1.31.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#911-914' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end
of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the
length of the slice, then the last chunk will not have length <code>chunk_size</code>.</p>
<p>See <a href="#method.rchunks_exact_mut"><code>rchunks_exact_mut</code></a> for a variant of this iterator that returns chunks of always
exactly <code>chunk_size</code> elements, and <a href="#method.chunks_mut"><code>chunks_mut</code></a> for the same iterator but starting at the
beginning of the slice.</p>
<h1 id="panics-7" class="section-header"><a href="#panics-7">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-26" class="section-header"><a href="#examples-26">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">1</span>;

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rchunks_mut</span>(<span class="number">2</span>) {
    <span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="ident">chunk</span>.<span class="ident">iter_mut</span>() {
        <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">+=</span> <span class="ident">count</span>;
    }
    <span class="ident">count</span> <span class="op">+=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.rchunks_exact' class="method"><code>pub fn <a href='#method.rchunks_exact' class='fnname'>rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.RChunksExact.html" title="struct core::slice::RChunksExact">RChunksExact</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.31.0'>1.31.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#950-955' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the
end of the slice.</p>
<p>The chunks are slices and do not overlap. If <code>chunk_size</code> does not divide the length of the
slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be retrieved
from the <code>remainder</code> function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the
resulting code better than in the case of <a href="#method.chunks"><code>chunks</code></a>.</p>
<p>See <a href="#method.rchunks"><code>rchunks</code></a> for a variant of this iterator that also returns the remainder as a smaller
chunk, and <a href="#method.chunks_exact"><code>chunks_exact</code></a> for the same iterator but starting at the beginning of the
slice.</p>
<h1 id="panics-8" class="section-header"><a href="#panics-8">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-27" class="section-header"><a href="#examples-27">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="string">&#39;l&#39;</span>, <span class="string">&#39;o&#39;</span>, <span class="string">&#39;r&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;m&#39;</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">rchunks_exact</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;e&#39;</span>, <span class="string">&#39;m&#39;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;o&#39;</span>, <span class="string">&#39;r&#39;</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="kw-2">&amp;</span>[<span class="string">&#39;l&#39;</span>]);</pre></div>
</div><h4 id='method.rchunks_exact_mut' class="method"><code>pub fn <a href='#method.rchunks_exact_mut' class='fnname'>rchunks_exact_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../core/slice/struct.RChunksExactMut.html" title="struct core::slice::RChunksExactMut">RChunksExactMut</a>&lt;T&gt;</code><span class='since' title='Stable since Rust version 1.31.0'>1.31.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#995-1000' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time, starting at the end
of the slice.</p>
<p>The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does not divide the
length of the slice, then the last up to <code>chunk_size-1</code> elements will be omitted and can be
retrieved from the <code>into_remainder</code> function of the iterator.</p>
<p>Due to each chunk having exactly <code>chunk_size</code> elements, the compiler can often optimize the
resulting code better than in the case of <a href="#method.chunks_mut"><code>chunks_mut</code></a>.</p>
<p>See <a href="#method.rchunks_mut"><code>rchunks_mut</code></a> for a variant of this iterator that also returns the remainder as a
smaller chunk, and <a href="#method.chunks_exact_mut"><code>chunks_exact_mut</code></a> for the same iterator but starting at the beginning
of the slice.</p>
<h1 id="panics-9" class="section-header"><a href="#panics-9">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
<h1 id="examples-28" class="section-header"><a href="#examples-28">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="kw-2">mut</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">1</span>;

<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rchunks_exact_mut</span>(<span class="number">2</span>) {
    <span class="kw">for</span> <span class="ident">elem</span> <span class="kw">in</span> <span class="ident">chunk</span>.<span class="ident">iter_mut</span>() {
        <span class="kw-2">*</span><span class="ident">elem</span> <span class="op">+=</span> <span class="ident">count</span>;
    }
    <span class="ident">count</span> <span class="op">+=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.split_at' class="method"><code>pub fn <a href='#method.split_at' class='fnname'>split_at</a>(&amp;self, mid: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1037-1039' title='goto source code'>[src]</a></h4><div class='docblock'><p>Divides one slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding
the index <code>mid</code> itself) and the second will contain all
indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>
<h1 id="panics-10" class="section-header"><a href="#panics-10">Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>
<h1 id="examples-29" class="section-header"><a href="#examples-29">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];

{
   <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at</span>(<span class="number">0</span>);
   <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">left</span> <span class="op">==</span> []);
   <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">right</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
}

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at</span>(<span class="number">2</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">left</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>]);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">right</span> <span class="op">==</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
}

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at</span>(<span class="number">6</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">left</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">right</span> <span class="op">==</span> []);
}</pre></div>
</div><h4 id='method.split_at_mut' class="method"><code>pub fn <a href='#method.split_at_mut' class='fnname'>split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1067-1076' title='goto source code'>[src]</a></h4><div class='docblock'><p>Divides one mutable slice into two at an index.</p>
<p>The first will contain all indices from <code>[0, mid)</code> (excluding
the index <code>mid</code> itself) and the second will contain all
indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>
<h1 id="panics-11" class="section-header"><a href="#panics-11">Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>
<h1 id="examples-30" class="section-header"><a href="#examples-30">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>];
<span class="comment">// scoped to restrict the lifetime of the borrows</span>
{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">left</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">0</span>]);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">right</span> <span class="op">==</span> [<span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>]);
    <span class="ident">left</span>[<span class="number">1</span>] <span class="op">=</span> <span class="number">2</span>;
    <span class="ident">right</span>[<span class="number">1</span>] <span class="op">=</span> <span class="number">4</span>;
}
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</pre></div>
</div><h4 id='method.split' class="method"><code>pub fn <a href='#method.split' class='fnname'>split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../core/slice/struct.Split.html" title="struct core::slice::Split">Split</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1120-1125' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>. The matched element is not contained in the subslices.</p>
<h1 id="examples-31" class="section-header"><a href="#examples-31">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">33</span>, <span class="number">20</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">20</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If the first element is matched, an empty slice will be the first item
returned by the iterator. Similarly, if the last element in the slice
is matched, an empty slice will be the last item returned by the
iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">33</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If two matched elements are directly adjacent, an empty slice will be
present between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">6</span>, <span class="number">33</span>, <span class="number">20</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">10</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">20</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.split_mut' class="method"><code>pub fn <a href='#method.split_mut' class='fnname'>split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../core/slice/struct.SplitMut.html" title="struct core::slice::SplitMut">SplitMut</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1142-1147' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over mutable subslices separated by elements that
match <code>pred</code>. The matched element is not contained in the subslices.</p>
<h1 id="examples-32" class="section-header"><a href="#examples-32">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">split_mut</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="ident">group</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="number">1</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">60</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.split_inclusive' class="method"><code>pub fn <a href='#method.split_inclusive' class='fnname'>split_inclusive</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../core/slice/struct.SplitInclusive.html" title="struct core::slice::SplitInclusive">SplitInclusive</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#1180-1185' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>split_inclusive</code>)</div></div><div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>. The matched element is contained in the end of the previous
subslice as a terminator.</p>
<h1 id="examples-33" class="section-header"><a href="#examples-33">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">split_inclusive</span>)]</span>
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">33</span>, <span class="number">20</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split_inclusive</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>, <span class="number">33</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">20</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
<p>If the last element of the slice is matched,
that element will be considered the terminator of the preceding slice.
That slice will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">split_inclusive</span>)]</span>
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">3</span>, <span class="number">10</span>, <span class="number">40</span>, <span class="number">33</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split_inclusive</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">3</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>, <span class="number">33</span>]);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</pre></div>
</div><h4 id='method.split_inclusive_mut' class="method"><code>pub fn <a href='#method.split_inclusive_mut' class='fnname'>split_inclusive_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../core/slice/struct.SplitInclusiveMut.html" title="struct core::slice::SplitInclusiveMut">SplitInclusiveMut</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#1205-1210' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>split_inclusive</code>)</div></div><div class='docblock'><p>Returns an iterator over mutable subslices separated by elements that
match <code>pred</code>. The matched element is contained in the previous
subslice as a terminator.</p>
<h1 id="examples-34" class="section-header"><a href="#examples-34">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">split_inclusive</span>)]</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">split_inclusive_mut</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="kw">let</span> <span class="ident">terminator_idx</span> <span class="op">=</span> <span class="ident">group</span>.<span class="ident">len</span>()<span class="op">-</span><span class="number">1</span>;
    <span class="ident">group</span>[<span class="ident">terminator_idx</span>] <span class="op">=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="number">10</span>, <span class="number">40</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.rsplit' class="method"><code>pub fn <a href='#method.rsplit' class='fnname'>rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../core/slice/struct.RSplit.html" title="struct core::slice::RSplit">RSplit</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.27.0'>1.27.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1241-1246' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>, starting at the end of the slice and working backwards.
The matched element is not contained in the subslices.</p>
<h1 id="examples-35" class="section-header"><a href="#examples-35">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">44</span>, <span class="number">55</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">num</span> <span class="op">==</span> <span class="number">0</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">44</span>, <span class="number">55</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">None</span>);</pre></div>
<p>As with <code>split()</code>, if the first or last element is matched, an empty
slice will be the first (or last) item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">it</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">n</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">n</span> <span class="op">%</span> <span class="number">2</span> <span class="op">==</span> <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">3</span>, <span class="number">5</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="kw-2">&amp;</span>[]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">it</span>.<span class="ident">next</span>(), <span class="prelude-val">None</span>);</pre></div>
</div><h4 id='method.rsplit_mut' class="method"><code>pub fn <a href='#method.rsplit_mut' class='fnname'>rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../core/slice/struct.RSplitMut.html" title="struct core::slice::RSplitMut">RSplitMut</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.27.0'>1.27.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1267-1272' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over mutable subslices separated by elements that
match <code>pred</code>, starting at the end of the slice and working
backwards. The matched element is not contained in the subslices.</p>
<h1 id="examples-36" class="section-header"><a href="#examples-36">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">100</span>, <span class="number">400</span>, <span class="number">300</span>, <span class="number">200</span>, <span class="number">600</span>, <span class="number">500</span>];

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">count</span> <span class="op">=</span> <span class="number">0</span>;
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rsplit_mut</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="ident">count</span> <span class="op">+=</span> <span class="number">1</span>;
    <span class="ident">group</span>[<span class="number">0</span>] <span class="op">=</span> <span class="ident">count</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="number">3</span>, <span class="number">400</span>, <span class="number">300</span>, <span class="number">2</span>, <span class="number">600</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.splitn' class="method"><code>pub fn <a href='#method.splitn' class='fnname'>splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="../std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../core/slice/struct.SplitN.html" title="struct core::slice::SplitN">SplitN</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1295-1300' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>, limited to returning at most <code>n</code> items. The matched element is
not contained in the subslices.</p>
<p>The last element returned, if any, will contain the remainder of the
slice.</p>
<h1 id="examples-37" class="section-header"><a href="#examples-37">Examples</a></h1>
<p>Print the slice split once by numbers divisible by 3 (i.e., <code>[10, 40]</code>,
<code>[20, 60, 50]</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">group</span>);
}</pre></div>
</div><h4 id='method.splitn_mut' class="method"><code>pub fn <a href='#method.splitn_mut' class='fnname'>splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="../std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../core/slice/struct.SplitNMut.html" title="struct core::slice::SplitNMut">SplitNMut</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1321-1326' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>, limited to returning at most <code>n</code> items. The matched element is
not contained in the subslices.</p>
<p>The last element returned, if any, will contain the remainder of the
slice.</p>
<h1 id="examples-38" class="section-header"><a href="#examples-38">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">splitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="ident">group</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="number">1</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">60</span>, <span class="number">50</span>]);</pre></div>
</div><h4 id='method.rsplitn' class="method"><code>pub fn <a href='#method.rsplitn' class='fnname'>rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="../std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../core/slice/struct.RSplitN.html" title="struct core::slice::RSplitN">RSplitN</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1350-1355' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of
the slice and works backwards. The matched element is not contained in
the subslices.</p>
<p>The last element returned, if any, will contain the remainder of the
slice.</p>
<h1 id="examples-39" class="section-header"><a href="#examples-39">Examples</a></h1>
<p>Print the slice split once, starting from the end, by numbers divisible
by 3 (i.e., <code>[50]</code>, <code>[10, 40, 30, 20]</code>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">group</span>);
}</pre></div>
</div><h4 id='method.rsplitn_mut' class="method"><code>pub fn <a href='#method.rsplitn_mut' class='fnname'>rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="../std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../core/slice/struct.RSplitNMut.html" title="struct core::slice::RSplitNMut">RSplitNMut</a>&lt;T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1377-1382' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns an iterator over subslices separated by elements that match
<code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of
the slice and works backwards. The matched element is not contained in
the subslices.</p>
<p>The last element returned, if any, will contain the remainder of the
slice.</p>
<h1 id="examples-40" class="section-header"><a href="#examples-40">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];

<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">s</span>.<span class="ident">rsplitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="ident">group</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">1</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, [<span class="number">1</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.contains' class="method"><code>pub fn <a href='#method.contains' class='fnname'>contains</a>(&amp;self, x: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;T&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1403-1408' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if the slice contains an element with the given value.</p>
<h1 id="examples-41" class="section-header"><a href="#examples-41">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">30</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">50</span>));</pre></div>
<p>If you do not have an <code>&amp;T</code>, but just an <code>&amp;U</code> such that <code>T: Borrow&lt;U&gt;</code>
(e.g. <code>String: Borrow&lt;str&gt;</code>), you can use <code>iter().any</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;hello&quot;</span>), <span class="ident">String</span>::<span class="ident">from</span>(<span class="string">&quot;world&quot;</span>)]; <span class="comment">// slice of `String`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">iter</span>().<span class="ident">any</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span> <span class="op">==</span> <span class="string">&quot;hello&quot;</span>)); <span class="comment">// search with `&amp;str`</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">iter</span>().<span class="ident">any</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span> <span class="op">==</span> <span class="string">&quot;hi&quot;</span>));</pre></div>
</div><h4 id='method.starts_with' class="method"><code>pub fn <a href='#method.starts_with' class='fnname'>starts_with</a>(&amp;self, needle: <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;T&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1431-1437' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if <code>needle</code> is a prefix of the slice.</p>
<h1 id="examples-42" class="section-header"><a href="#examples-42">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">50</span>]));</pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[]));
<span class="kw">let</span> <span class="ident">v</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[]));</pre></div>
</div><h4 id='method.ends_with' class="method"><code>pub fn <a href='#method.ends_with' class='fnname'>ends_with</a>(&amp;self, needle: <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;T&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1460-1466' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns <code>true</code> if <code>needle</code> is a suffix of the slice.</p>
<h1 id="examples-43" class="section-header"><a href="#examples-43">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[<span class="number">30</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[<span class="number">40</span>, <span class="number">30</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>, <span class="number">30</span>]));</pre></div>
<p>Always returns <code>true</code> if <code>needle</code> is an empty slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[]));
<span class="kw">let</span> <span class="ident">v</span>: <span class="kw-2">&amp;</span>[<span class="ident">u8</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[]));</pre></div>
</div><h4 id='method.strip_prefix' class="method"><code><span class="docblock attributes">#[must_use = "returns the subslice without modifying the original"]</span>pub fn <a href='#method.strip_prefix' class='fnname'>strip_prefix</a>(&amp;self, prefix: <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;T&gt;,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#1485-1497' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_strip</code>)</div></div><div class='docblock'><p>Returns a subslice with the prefix removed.</p>
<p>This method returns <a href="../core/option/enum.Option.html#variant.None" title="`None`"><code>None</code></a> if slice does not start with <code>prefix</code>.
Also it returns the original slice if <code>prefix</code> is an empty slice.</p>
<h1 id="examples-44" class="section-header"><a href="#examples-44">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_strip</span>)]</span>
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">strip_prefix</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>]), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">40</span>, <span class="number">30</span>][..]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">strip_prefix</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>]), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">30</span>][..]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">strip_prefix</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>]), <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">strip_prefix</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">50</span>]), <span class="prelude-val">None</span>);</pre></div>
</div><h4 id='method.strip_suffix' class="method"><code><span class="docblock attributes">#[must_use = "returns the subslice without modifying the original"]</span>pub fn <a href='#method.strip_suffix' class='fnname'>strip_suffix</a>(&amp;self, suffix: <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;T&gt;,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#1516-1528' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_strip</code>)</div></div><div class='docblock'><p>Returns a subslice with the suffix removed.</p>
<p>This method returns <a href="../core/option/enum.Option.html#variant.None" title="`None`"><code>None</code></a> if slice does not end with <code>suffix</code>.
Also it returns the original slice if <code>suffix</code> is an empty slice</p>
<h1 id="examples-45" class="section-header"><a href="#examples-45">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_strip</span>)]</span>
<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">strip_suffix</span>(<span class="kw-2">&amp;</span>[<span class="number">30</span>]), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>][..]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">strip_suffix</span>(<span class="kw-2">&amp;</span>[<span class="number">40</span>, <span class="number">30</span>]), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>][..]));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">strip_suffix</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>]), <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">strip_suffix</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>, <span class="number">30</span>]), <span class="prelude-val">None</span>);</pre></div>
</div><h4 id='method.binary_search' class="method"><code>pub fn <a href='#method.binary_search' class='fnname'>binary_search</a>(&amp;self, x: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="../std/primitive.usize.html">usize</a>, <a class="primitive" href="../std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1565-1570' title='goto source code'>[src]</a></h4><div class='docblock'><p>Binary searches this sorted slice for a given element.</p>
<p>If the value is found then <a href="../core/result/enum.Result.html#variant.Ok" title="`Result::Ok`"><code>Result::Ok</code></a> is returned, containing the
index of the matching element. If there are multiple matches, then any
one of the matches could be returned. If the value is not found then
<a href="../core/result/enum.Result.html#variant.Err" title="`Result::Err`"><code>Result::Err</code></a> is returned, containing the index where a matching
element could be inserted while maintaining sorted order.</p>
<h1 id="examples-46" class="section-header"><a href="#examples-46">Examples</a></h1>
<p>Looks up a series of four elements. The first is found, with a
uniquely determined position; the second and third are not
found; the fourth could match any position in <code>[1, 4]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="number">13</span>),  <span class="prelude-val">Ok</span>(<span class="number">9</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="number">4</span>),   <span class="prelude-val">Err</span>(<span class="number">7</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="number">100</span>), <span class="prelude-val">Err</span>(<span class="number">13</span>));
<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="number">1</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="kw">match</span> <span class="ident">r</span> { <span class="prelude-val">Ok</span>(<span class="number">1</span>..<span class="op">=</span><span class="number">4</span>) <span class="op">=&gt;</span> <span class="bool-val">true</span>, <span class="kw">_</span> <span class="op">=&gt;</span> <span class="bool-val">false</span>, });</pre></div>
<p>If you want to insert an item to a sorted vector, while maintaining
sort order:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>];
<span class="kw">let</span> <span class="ident">num</span> <span class="op">=</span> <span class="number">42</span>;
<span class="kw">let</span> <span class="ident">idx</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="ident">num</span>).<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span>);
<span class="ident">s</span>.<span class="ident">insert</span>(<span class="ident">idx</span>, <span class="ident">num</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">55</span>]);</pre></div>
</div><h4 id='method.binary_search_by' class="method"><code>pub fn <a href='#method.binary_search_by' class='fnname'>binary_search_by</a>&lt;'a, F&gt;(&amp;'a self, f: F) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="../std/primitive.usize.html">usize</a>, <a class="primitive" href="../std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;'a </a>T) -&gt; <a class="enum" href="../core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1606-1629' title='goto source code'>[src]</a></h4><div class='docblock'><p>Binary searches this sorted slice with a comparator function.</p>
<p>The comparator function should implement an order consistent
with the sort order of the underlying slice, returning an
order code that indicates whether its argument is <code>Less</code>,
<code>Equal</code> or <code>Greater</code> the desired target.</p>
<p>If the value is found then <a href="../core/result/enum.Result.html#variant.Ok" title="`Result::Ok`"><code>Result::Ok</code></a> is returned, containing the
index of the matching element. If there are multiple matches, then any
one of the matches could be returned. If the value is not found then
<a href="../core/result/enum.Result.html#variant.Err" title="`Result::Err`"><code>Result::Err</code></a> is returned, containing the index where a matching
element could be inserted while maintaining sorted order.</p>
<h1 id="examples-47" class="section-header"><a href="#examples-47">Examples</a></h1>
<p>Looks up a series of four elements. The first is found, with a
uniquely determined position; the second and third are not
found; the fourth could match any position in <code>[1, 4]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>];

<span class="kw">let</span> <span class="ident">seek</span> <span class="op">=</span> <span class="number">13</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by</span>(<span class="op">|</span><span class="ident">probe</span><span class="op">|</span> <span class="ident">probe</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">seek</span>)), <span class="prelude-val">Ok</span>(<span class="number">9</span>));
<span class="kw">let</span> <span class="ident">seek</span> <span class="op">=</span> <span class="number">4</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by</span>(<span class="op">|</span><span class="ident">probe</span><span class="op">|</span> <span class="ident">probe</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">seek</span>)), <span class="prelude-val">Err</span>(<span class="number">7</span>));
<span class="kw">let</span> <span class="ident">seek</span> <span class="op">=</span> <span class="number">100</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by</span>(<span class="op">|</span><span class="ident">probe</span><span class="op">|</span> <span class="ident">probe</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">seek</span>)), <span class="prelude-val">Err</span>(<span class="number">13</span>));
<span class="kw">let</span> <span class="ident">seek</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">binary_search_by</span>(<span class="op">|</span><span class="ident">probe</span><span class="op">|</span> <span class="ident">probe</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">seek</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="kw">match</span> <span class="ident">r</span> { <span class="prelude-val">Ok</span>(<span class="number">1</span>..<span class="op">=</span><span class="number">4</span>) <span class="op">=&gt;</span> <span class="bool-val">true</span>, <span class="kw">_</span> <span class="op">=&gt;</span> <span class="bool-val">false</span>, });</pre></div>
</div><h4 id='method.binary_search_by_key' class="method"><code>pub fn <a href='#method.binary_search_by_key' class='fnname'>binary_search_by_key</a>&lt;'a, B, F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a self, <br>&nbsp;&nbsp;&nbsp;&nbsp;b: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>B, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F<br>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="../std/primitive.usize.html">usize</a>, <a class="primitive" href="../std/primitive.usize.html">usize</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;B: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;'a </a>T) -&gt; B,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.10.0'>1.10.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1664-1670' title='goto source code'>[src]</a></h4><div class='docblock'><p>Binary searches this sorted slice with a key extraction function.</p>
<p>Assumes that the slice is sorted by the key, for instance with
<a href="#method.sort_by_key"><code>sort_by_key</code></a> using the same key extraction function.</p>
<p>If the value is found then <a href="../core/result/enum.Result.html#variant.Ok" title="`Result::Ok`"><code>Result::Ok</code></a> is returned, containing the
index of the matching element. If there are multiple matches, then any
one of the matches could be returned. If the value is not found then
<a href="../core/result/enum.Result.html#variant.Err" title="`Result::Err`"><code>Result::Err</code></a> is returned, containing the index where a matching
element could be inserted while maintaining sorted order.</p>
<h1 id="examples-48" class="section-header"><a href="#examples-48">Examples</a></h1>
<p>Looks up a series of four elements in a slice of pairs sorted by
their second elements. The first is found, with a uniquely
determined position; the second and third are not found; the
fourth could match any position in <code>[1, 4]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>),
         (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">13</span>),
         (<span class="number">1</span>, <span class="number">21</span>), (<span class="number">2</span>, <span class="number">34</span>), (<span class="number">4</span>, <span class="number">55</span>)];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by_key</span>(<span class="kw-2">&amp;</span><span class="number">13</span>, <span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">a</span>,<span class="ident">b</span>)<span class="op">|</span> <span class="ident">b</span>),  <span class="prelude-val">Ok</span>(<span class="number">9</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by_key</span>(<span class="kw-2">&amp;</span><span class="number">4</span>, <span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">a</span>,<span class="ident">b</span>)<span class="op">|</span> <span class="ident">b</span>),   <span class="prelude-val">Err</span>(<span class="number">7</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by_key</span>(<span class="kw-2">&amp;</span><span class="number">100</span>, <span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">a</span>,<span class="ident">b</span>)<span class="op">|</span> <span class="ident">b</span>), <span class="prelude-val">Err</span>(<span class="number">13</span>));
<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">binary_search_by_key</span>(<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">a</span>,<span class="ident">b</span>)<span class="op">|</span> <span class="ident">b</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="kw">match</span> <span class="ident">r</span> { <span class="prelude-val">Ok</span>(<span class="number">1</span>..<span class="op">=</span><span class="number">4</span>) <span class="op">=&gt;</span> <span class="bool-val">true</span>, <span class="kw">_</span> <span class="op">=&gt;</span> <span class="bool-val">false</span>, });</pre></div>
</div><h4 id='method.sort_unstable' class="method"><code>pub fn <a href='#method.sort_unstable' class='fnname'>sort_unstable</a>(&amp;mut self) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.20.0'>1.20.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1700-1705' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sorts the slice, but may not preserve the order of equal elements.</p>
<p>This sort is unstable (i.e., may reorder equal elements), in-place
(i.e., does not allocate), and <em>O</em>(<em>n</em> * log(<em>n</em>)) worst-case.</p>
<h1 id="current-implementation" class="section-header"><a href="#current-implementation">Current implementation</a></h1>
<p>The current algorithm is based on <a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> by Orson Peters,
which combines the fast average case of randomized quicksort with the fast worst case of
heapsort, while achieving linear time on slices with certain patterns. It uses some
randomization to avoid degenerate cases, but with a fixed seed to always provide
deterministic behavior.</p>
<p>It is typically faster than stable sorting, except in a few special cases, e.g., when the
slice consists of several concatenated sorted sequences.</p>
<h1 id="examples-49" class="section-header"><a href="#examples-49">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="ident">v</span>.<span class="ident">sort_unstable</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="op">-</span><span class="number">5</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</pre></div>
</div><h4 id='method.sort_unstable_by' class="method"><code>pub fn <a href='#method.sort_unstable_by' class='fnname'>sort_unstable_by</a>&lt;F&gt;(&amp;mut self, compare: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T, <a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="enum" href="../core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.20.0'>1.20.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1755-1760' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sorts the slice with a comparator function, but may not preserve the order of equal
elements.</p>
<p>This sort is unstable (i.e., may reorder equal elements), in-place
(i.e., does not allocate), and <em>O</em>(<em>n</em> * log(<em>n</em>)) worst-case.</p>
<p>The comparator function must define a total ordering for the elements in the slice. If
the ordering is not total, the order of the elements is unspecified. An order is a
total order if it is (for all a, b and c):</p>
<ul>
<li>total and antisymmetric: exactly one of a &lt; b, a == b or a &gt; b is true; and</li>
<li>transitive, a &lt; b and b &lt; c implies a &lt; c. The same must hold for both == and &gt;.</li>
</ul>
<p>For example, while <a href="../std/primitive.f64.html" title="`f64`"><code>f64</code></a> doesn't implement <a href="../core/cmp/trait.Ord.html" title="`Ord`"><code>Ord</code></a> because <code>NaN != NaN</code>, we can use
<code>partial_cmp</code> as our sort function when we know the slice doesn't contain a <code>NaN</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">floats</span> <span class="op">=</span> [<span class="number">5f64</span>, <span class="number">4.0</span>, <span class="number">1.0</span>, <span class="number">3.0</span>, <span class="number">2.0</span>];
<span class="ident">floats</span>.<span class="ident">sort_unstable_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">a</span>.<span class="ident">partial_cmp</span>(<span class="ident">b</span>).<span class="ident">unwrap</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">floats</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>]);</pre></div>
<h1 id="current-implementation-1" class="section-header"><a href="#current-implementation-1">Current implementation</a></h1>
<p>The current algorithm is based on <a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> by Orson Peters,
which combines the fast average case of randomized quicksort with the fast worst case of
heapsort, while achieving linear time on slices with certain patterns. It uses some
randomization to avoid degenerate cases, but with a fixed seed to always provide
deterministic behavior.</p>
<p>It is typically faster than stable sorting, except in a few special cases, e.g., when the
slice consists of several concatenated sorted sequences.</p>
<h1 id="examples-50" class="section-header"><a href="#examples-50">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>];
<span class="ident">v</span>.<span class="ident">sort_unstable_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">a</span>.<span class="ident">cmp</span>(<span class="ident">b</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="comment">// reverse sorting</span>
<span class="ident">v</span>.<span class="ident">sort_unstable_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">b</span>.<span class="ident">cmp</span>(<span class="ident">a</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.sort_unstable_by_key' class="method"><code>pub fn <a href='#method.sort_unstable_by_key' class='fnname'>sort_unstable_by_key</a>&lt;K, F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; K,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.20.0'>1.20.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#1793-1799' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sorts the slice with a key extraction function, but may not preserve the order of equal
elements.</p>
<p>This sort is unstable (i.e., may reorder equal elements), in-place
(i.e., does not allocate), and <em>O</em>(m * <em>n</em> * log(<em>n</em>)) worst-case, where the key function is
<em>O</em>(<em>m</em>).</p>
<h1 id="current-implementation-2" class="section-header"><a href="#current-implementation-2">Current implementation</a></h1>
<p>The current algorithm is based on <a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> by Orson Peters,
which combines the fast average case of randomized quicksort with the fast worst case of
heapsort, while achieving linear time on slices with certain patterns. It uses some
randomization to avoid degenerate cases, but with a fixed seed to always provide
deterministic behavior.</p>
<p>Due to its key calling strategy, <a href="#method.sort_unstable_by_key"><code>sort_unstable_by_key</code></a>
is likely to be slower than <a href="#method.sort_by_cached_key"><code>sort_by_cached_key</code></a> in
cases where the key function is expensive.</p>
<h1 id="examples-51" class="section-header"><a href="#examples-51">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5i32</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="ident">v</span>.<span class="ident">sort_unstable_by_key</span>(<span class="op">|</span><span class="ident">k</span><span class="op">|</span> <span class="ident">k</span>.<span class="ident">abs</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">4</span>, <span class="op">-</span><span class="number">5</span>]);</pre></div>
</div><h4 id='method.partition_at_index' class="method"><code>pub fn <a href='#method.partition_at_index' class='fnname'>partition_at_index</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: <a class="primitive" href="../std/primitive.usize.html">usize</a><br>) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#1841-1847' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_partition_at_index</code>)</div></div><div class='docblock'><p>Reorder the slice such that the element at <code>index</code> is at its final sorted position.</p>
<p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be
less than or equal to any value at a position <code>j &gt; index</code>. Additionally, this reordering is
unstable (i.e. any number of equal elements may end up at position <code>index</code>), in-place
(i.e. does not allocate), and <em>O</em>(<em>n</em>) worst-case. This function is also/ known as &quot;kth
element&quot; in other libraries. It returns a triplet of the following values: all elements less
than the one at the given index, the value at the given index, and all elements greater than
the one at the given index.</p>
<h1 id="current-implementation-3" class="section-header"><a href="#current-implementation-3">Current implementation</a></h1>
<p>The current algorithm is based on the quickselect portion of the same quicksort algorithm
used for <a href="#method.sort_unstable"><code>sort_unstable</code></a>.</p>
<h1 id="panics-12" class="section-header"><a href="#panics-12">Panics</a></h1>
<p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p>
<h1 id="examples-52" class="section-header"><a href="#examples-52">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_partition_at_index</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5i32</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="comment">// Find the median</span>
<span class="ident">v</span>.<span class="ident">partition_at_index</span>(<span class="number">2</span>);

<span class="comment">// We are only guaranteed the slice will be one of the following, based on the way we sort</span>
<span class="comment">// about the specified index.</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="op">-</span><span class="number">3</span>, <span class="op">-</span><span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="op">-</span><span class="number">5</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="op">-</span><span class="number">3</span>, <span class="op">-</span><span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="op">-</span><span class="number">5</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]);</pre></div>
</div><h4 id='method.partition_at_index_by' class="method"><code>pub fn <a href='#method.partition_at_index_by' class='fnname'>partition_at_index_by</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: <a class="primitive" href="../std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;compare: F<br>) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T, <a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="enum" href="../core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#1891-1901' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_partition_at_index</code>)</div></div><div class='docblock'><p>Reorder the slice with a comparator function such that the element at <code>index</code> is at its
final sorted position.</p>
<p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be
less than or equal to any value at a position <code>j &gt; index</code> using the comparator function.
Additionally, this reordering is unstable (i.e. any number of equal elements may end up at
position <code>index</code>), in-place (i.e. does not allocate), and <em>O</em>(<em>n</em>) worst-case. This function
is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following
values: all elements less than the one at the given index, the value at the given index,
and all elements greater than the one at the given index, using the provided comparator
function.</p>
<h1 id="current-implementation-4" class="section-header"><a href="#current-implementation-4">Current implementation</a></h1>
<p>The current algorithm is based on the quickselect portion of the same quicksort algorithm
used for <a href="#method.sort_unstable"><code>sort_unstable</code></a>.</p>
<h1 id="panics-13" class="section-header"><a href="#panics-13">Panics</a></h1>
<p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p>
<h1 id="examples-53" class="section-header"><a href="#examples-53">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_partition_at_index</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5i32</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="comment">// Find the median as if the slice were sorted in descending order.</span>
<span class="ident">v</span>.<span class="ident">partition_at_index_by</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">b</span>.<span class="ident">cmp</span>(<span class="ident">a</span>));

<span class="comment">// We are only guaranteed the slice will be one of the following, based on the way we sort</span>
<span class="comment">// about the specified index.</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">5</span>, <span class="op">-</span><span class="number">3</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="op">-</span><span class="number">5</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">5</span>, <span class="op">-</span><span class="number">3</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="op">-</span><span class="number">5</span>]);</pre></div>
</div><h4 id='method.partition_at_index_by_key' class="method"><code>pub fn <a href='#method.partition_at_index_by_key' class='fnname'>partition_at_index_by_key</a>&lt;K, F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index: <a class="primitive" href="../std/primitive.usize.html">usize</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F<br>) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; K,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#1945-1956' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_partition_at_index</code>)</div></div><div class='docblock'><p>Reorder the slice with a key extraction function such that the element at <code>index</code> is at its
final sorted position.</p>
<p>This reordering has the additional property that any value at position <code>i &lt; index</code> will be
less than or equal to any value at a position <code>j &gt; index</code> using the key extraction function.
Additionally, this reordering is unstable (i.e. any number of equal elements may end up at
position <code>index</code>), in-place (i.e. does not allocate), and <em>O</em>(<em>n</em>) worst-case. This function
is also known as &quot;kth element&quot; in other libraries. It returns a triplet of the following
values: all elements less than the one at the given index, the value at the given index, and
all elements greater than the one at the given index, using the provided key extraction
function.</p>
<h1 id="current-implementation-5" class="section-header"><a href="#current-implementation-5">Current implementation</a></h1>
<p>The current algorithm is based on the quickselect portion of the same quicksort algorithm
used for <a href="#method.sort_unstable"><code>sort_unstable</code></a>.</p>
<h1 id="panics-14" class="section-header"><a href="#panics-14">Panics</a></h1>
<p>Panics when <code>index &gt;= len()</code>, meaning it always panics on empty slices.</p>
<h1 id="examples-54" class="section-header"><a href="#examples-54">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_partition_at_index</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5i32</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="comment">// Return the median as if the array were sorted according to absolute value.</span>
<span class="ident">v</span>.<span class="ident">partition_at_index_by_key</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">a</span><span class="op">|</span> <span class="ident">a</span>.<span class="ident">abs</span>());

<span class="comment">// We are only guaranteed the slice will be one of the following, based on the way we sort</span>
<span class="comment">// about the specified index.</span>
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">4</span>, <span class="op">-</span><span class="number">5</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="op">-</span><span class="number">3</span>, <span class="op">-</span><span class="number">5</span>, <span class="number">4</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="number">2</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">4</span>, <span class="op">-</span><span class="number">5</span>] <span class="op">||</span>
        <span class="ident">v</span> <span class="op">==</span> [<span class="number">2</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="op">-</span><span class="number">5</span>, <span class="number">4</span>]);</pre></div>
</div><h4 id='method.partition_dedup' class="method"><code>pub fn <a href='#method.partition_dedup' class='fnname'>partition_dedup</a>(&amp;mut self) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;T&gt;,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#1980-1985' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_partition_dedup</code>)</div></div><div class='docblock'><p>Moves all consecutive repeated elements to the end of the slice according to the
<a href="../core/cmp/trait.PartialEq.html" title="`PartialEq`"><code>PartialEq</code></a> trait implementation.</p>
<p>Returns two slices. The first contains no consecutive repeated elements.
The second contains all the duplicates in no specified order.</p>
<p>If the slice is sorted, the first returned slice contains no duplicates.</p>
<h1 id="examples-55" class="section-header"><a href="#examples-55">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_partition_dedup</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>];

<span class="kw">let</span> (<span class="ident">dedup</span>, <span class="ident">duplicates</span>) <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">partition_dedup</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dedup</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">duplicates</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.partition_dedup_by' class="method"><code>pub fn <a href='#method.partition_dedup_by' class='fnname'>partition_dedup_by</a>&lt;F&gt;(&amp;mut self, same_bucket: F) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T, <a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#2014-2101' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_partition_dedup</code>)</div></div><div class='docblock'><p>Moves all but the first of consecutive elements to the end of the slice satisfying
a given equality relation.</p>
<p>Returns two slices. The first contains no consecutive repeated elements.
The second contains all the duplicates in no specified order.</p>
<p>The <code>same_bucket</code> function is passed references to two elements from the slice and
must determine if the elements compare equal. The elements are passed in opposite order
from their order in the slice, so if <code>same_bucket(a, b)</code> returns <code>true</code>, <code>a</code> is moved
at the end of the slice.</p>
<p>If the slice is sorted, the first returned slice contains no duplicates.</p>
<h1 id="examples-56" class="section-header"><a href="#examples-56">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_partition_dedup</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;BAZ&quot;</span>, <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;BAZ&quot;</span>];

<span class="kw">let</span> (<span class="ident">dedup</span>, <span class="ident">duplicates</span>) <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">partition_dedup_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">a</span>.<span class="ident">eq_ignore_ascii_case</span>(<span class="ident">b</span>));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dedup</span>, [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;BAZ&quot;</span>, <span class="string">&quot;Bar&quot;</span>, <span class="string">&quot;baz&quot;</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">duplicates</span>, [<span class="string">&quot;bar&quot;</span>, <span class="string">&quot;Foo&quot;</span>, <span class="string">&quot;BAZ&quot;</span>]);</pre></div>
</div><h4 id='method.partition_dedup_by_key' class="method"><code>pub fn <a href='#method.partition_dedup_by_key' class='fnname'>partition_dedup_by_key</a>&lt;K, F&gt;(&amp;mut self, key: F) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T) -&gt; K,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;K&gt;,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#2125-2131' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_partition_dedup</code>)</div></div><div class='docblock'><p>Moves all but the first of consecutive elements to the end of the slice that resolve
to the same key.</p>
<p>Returns two slices. The first contains no consecutive repeated elements.
The second contains all the duplicates in no specified order.</p>
<p>If the slice is sorted, the first returned slice contains no duplicates.</p>
<h1 id="examples-57" class="section-header"><a href="#examples-57">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_partition_dedup</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">13</span>];

<span class="kw">let</span> (<span class="ident">dedup</span>, <span class="ident">duplicates</span>) <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">partition_dedup_by_key</span>(<span class="op">|</span><span class="ident">i</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">i</span> <span class="op">/</span> <span class="number">10</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dedup</span>, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">11</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">duplicates</span>, [<span class="number">21</span>, <span class="number">30</span>, <span class="number">13</span>]);</pre></div>
</div><h4 id='method.rotate_left' class="method"><code>pub fn <a href='#method.rotate_left' class='fnname'>rotate_left</a>(&amp;mut self, mid: <a class="primitive" href="../std/primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2164-2172' title='goto source code'>[src]</a></h4><div class='docblock'><p>Rotates the slice in-place such that the first <code>mid</code> elements of the
slice move to the end while the last <code>self.len() - mid</code> elements move to
the front. After calling <code>rotate_left</code>, the element previously at index
<code>mid</code> will become the first element in the slice.</p>
<h1 id="panics-15" class="section-header"><a href="#panics-15">Panics</a></h1>
<p>This function will panic if <code>mid</code> is greater than the length of the
slice. Note that <code>mid == self.len()</code> does <em>not</em> panic and is a no-op
rotation.</p>
<h1 id="complexity" class="section-header"><a href="#complexity">Complexity</a></h1>
<p>Takes linear (in <code>self.len()</code>) time.</p>
<h1 id="examples-58" class="section-header"><a href="#examples-58">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> [<span class="string">&#39;a&#39;</span>, <span class="string">&#39;b&#39;</span>, <span class="string">&#39;c&#39;</span>, <span class="string">&#39;d&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;f&#39;</span>];
<span class="ident">a</span>.<span class="ident">rotate_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, [<span class="string">&#39;c&#39;</span>, <span class="string">&#39;d&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;f&#39;</span>, <span class="string">&#39;a&#39;</span>, <span class="string">&#39;b&#39;</span>]);</pre></div>
<p>Rotating a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> [<span class="string">&#39;a&#39;</span>, <span class="string">&#39;b&#39;</span>, <span class="string">&#39;c&#39;</span>, <span class="string">&#39;d&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;f&#39;</span>];
<span class="ident">a</span>[<span class="number">1</span>..<span class="number">5</span>].<span class="ident">rotate_left</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, [<span class="string">&#39;a&#39;</span>, <span class="string">&#39;c&#39;</span>, <span class="string">&#39;d&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;b&#39;</span>, <span class="string">&#39;f&#39;</span>]);</pre></div>
</div><h4 id='method.rotate_right' class="method"><code>pub fn <a href='#method.rotate_right' class='fnname'>rotate_right</a>(&amp;mut self, k: <a class="primitive" href="../std/primitive.usize.html">usize</a>)</code><span class='since' title='Stable since Rust version 1.26.0'>1.26.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2205-2213' title='goto source code'>[src]</a></h4><div class='docblock'><p>Rotates the slice in-place such that the first <code>self.len() - k</code>
elements of the slice move to the end while the last <code>k</code> elements move
to the front. After calling <code>rotate_right</code>, the element previously at
index <code>self.len() - k</code> will become the first element in the slice.</p>
<h1 id="panics-16" class="section-header"><a href="#panics-16">Panics</a></h1>
<p>This function will panic if <code>k</code> is greater than the length of the
slice. Note that <code>k == self.len()</code> does <em>not</em> panic and is a no-op
rotation.</p>
<h1 id="complexity-1" class="section-header"><a href="#complexity-1">Complexity</a></h1>
<p>Takes linear (in <code>self.len()</code>) time.</p>
<h1 id="examples-59" class="section-header"><a href="#examples-59">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> [<span class="string">&#39;a&#39;</span>, <span class="string">&#39;b&#39;</span>, <span class="string">&#39;c&#39;</span>, <span class="string">&#39;d&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;f&#39;</span>];
<span class="ident">a</span>.<span class="ident">rotate_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, [<span class="string">&#39;e&#39;</span>, <span class="string">&#39;f&#39;</span>, <span class="string">&#39;a&#39;</span>, <span class="string">&#39;b&#39;</span>, <span class="string">&#39;c&#39;</span>, <span class="string">&#39;d&#39;</span>]);</pre></div>
<p>Rotate a subslice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> [<span class="string">&#39;a&#39;</span>, <span class="string">&#39;b&#39;</span>, <span class="string">&#39;c&#39;</span>, <span class="string">&#39;d&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;f&#39;</span>];
<span class="ident">a</span>[<span class="number">1</span>..<span class="number">5</span>].<span class="ident">rotate_right</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>, [<span class="string">&#39;a&#39;</span>, <span class="string">&#39;e&#39;</span>, <span class="string">&#39;b&#39;</span>, <span class="string">&#39;c&#39;</span>, <span class="string">&#39;d&#39;</span>, <span class="string">&#39;f&#39;</span>]);</pre></div>
</div><h4 id='method.fill' class="method"><code>pub fn <a href='#method.fill' class='fnname'>fill</a>(&amp;mut self, value: T) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#2227-2238' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>slice_fill</code>)</div></div><div class='docblock'><p>Fills <code>self</code> with elements by cloning <code>value</code>.</p>
<h1 id="examples-60" class="section-header"><a href="#examples-60">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">slice_fill</span>)]</span>

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">10</span>];
<span class="ident">buf</span>.<span class="ident">fill</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buf</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">10</span>]);</pre></div>
</div><h4 id='method.clone_from_slice' class="method"><code>pub fn <a href='#method.clone_from_slice' class='fnname'>clone_from_slice</a>(&amp;mut self, src: <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.7.0'>1.7.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2296-2309' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies the elements from <code>src</code> into <code>self</code>.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<p>If <code>T</code> implements <code>Copy</code>, it can be more performant to use
<a href="#method.copy_from_slice"><code>copy_from_slice</code></a>.</p>
<h1 id="panics-17" class="section-header"><a href="#panics-17">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="examples-61" class="section-header"><a href="#examples-61">Examples</a></h1>
<p>Cloning two elements from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">0</span>];

<span class="comment">// Because the slices have to be the same length,</span>
<span class="comment">// we slice the source slice from four elements</span>
<span class="comment">// to two. It will panic if we don&#39;t do this.</span>
<span class="ident">dst</span>.<span class="ident">clone_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>[<span class="number">2</span>..]);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dst</span>, [<span class="number">3</span>, <span class="number">4</span>]);</pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use <code>clone_from_slice</code> on a
single slice will result in a compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ<span class='tooltiptext'>This example deliberately fails to compile</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="ident">slice</span>[..<span class="number">2</span>].<span class="ident">clone_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">slice</span>[<span class="number">3</span>..]); <span class="comment">// compile fail!</span></pre></div>
<p>To work around this, we can use <a href="#method.split_at_mut"><code>split_at_mut</code></a> to create two distinct
sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
    <span class="ident">left</span>.<span class="ident">clone_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">right</span>[<span class="number">1</span>..]);
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">slice</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</pre></div>
</div><h4 id='method.copy_from_slice' class="method"><code>pub fn <a href='#method.copy_from_slice' class='fnname'>copy_from_slice</a>(&amp;mut self, src: <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.9.0'>1.9.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2366-2374' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies all elements from <code>src</code> into <code>self</code>, using a memcpy.</p>
<p>The length of <code>src</code> must be the same as <code>self</code>.</p>
<p>If <code>T</code> does not implement <code>Copy</code>, use <a href="#method.clone_from_slice"><code>clone_from_slice</code></a>.</p>
<h1 id="panics-18" class="section-header"><a href="#panics-18">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="examples-62" class="section-header"><a href="#examples-62">Examples</a></h1>
<p>Copying two elements from a slice into another:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">0</span>];

<span class="comment">// Because the slices have to be the same length,</span>
<span class="comment">// we slice the source slice from four elements</span>
<span class="comment">// to two. It will panic if we don&#39;t do this.</span>
<span class="ident">dst</span>.<span class="ident">copy_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>[<span class="number">2</span>..]);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">dst</span>, [<span class="number">3</span>, <span class="number">4</span>]);</pre></div>
<p>Rust enforces that there can only be one mutable reference with no
immutable references to a particular piece of data in a particular
scope. Because of this, attempting to use <code>copy_from_slice</code> on a
single slice will result in a compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ<span class='tooltiptext'>This example deliberately fails to compile</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="ident">slice</span>[..<span class="number">2</span>].<span class="ident">copy_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">slice</span>[<span class="number">3</span>..]); <span class="comment">// compile fail!</span></pre></div>
<p>To work around this, we can use <a href="#method.split_at_mut"><code>split_at_mut</code></a> to create two distinct
sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
    <span class="ident">left</span>.<span class="ident">copy_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">right</span>[<span class="number">1</span>..]);
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">slice</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</pre></div>
</div><h4 id='method.copy_within' class="method"><code>pub fn <a href='#method.copy_within' class='fnname'>copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="../std/primitive.usize.html">usize</a>) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../core/ops/range/trait.RangeBounds.html" title="trait core::ops::range::RangeBounds">RangeBounds</a>&lt;<a class="primitive" href="../std/primitive.usize.html">usize</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.37.0'>1.37.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2402-2427' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies elements from one part of the slice to another part of itself,
using a memmove.</p>
<p><code>src</code> is the range within <code>self</code> to copy from. <code>dest</code> is the starting
index of the range within <code>self</code> to copy to, which will have the same
length as <code>src</code>. The two ranges may overlap. The ends of the two ranges
must be less than or equal to <code>self.len()</code>.</p>
<h1 id="panics-19" class="section-header"><a href="#panics-19">Panics</a></h1>
<p>This function will panic if either range exceeds the end of the slice,
or if the end of <code>src</code> is before the start.</p>
<h1 id="examples-63" class="section-header"><a href="#examples-63">Examples</a></h1>
<p>Copying four bytes within a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span> <span class="op">=</span> <span class="kw-2">*</span><span class="string">b&quot;Hello, World!&quot;</span>;

<span class="ident">bytes</span>.<span class="ident">copy_within</span>(<span class="number">1</span>..<span class="number">5</span>, <span class="number">8</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">bytes</span>, <span class="string">b&quot;Hello, Wello!&quot;</span>);</pre></div>
</div><h4 id='method.swap_with_slice' class="method"><code>pub fn <a href='#method.swap_with_slice' class='fnname'>swap_with_slice</a>(&amp;mut self, other: <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>)</code><span class='since' title='Stable since Rust version 1.27.0'>1.27.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2477-2482' title='goto source code'>[src]</a></h4><div class='docblock'><p>Swaps all elements in <code>self</code> with those in <code>other</code>.</p>
<p>The length of <code>other</code> must be the same as <code>self</code>.</p>
<h1 id="panics-20" class="section-header"><a href="#panics-20">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<p>Swapping two elements across slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice1</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice2</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];

<span class="ident">slice1</span>.<span class="ident">swap_with_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">slice2</span>[<span class="number">2</span>..]);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">slice1</span>, [<span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">slice2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>]);</pre></div>
<p>Rust enforces that there can only be one mutable reference to a
particular piece of data in a particular scope. Because of this,
attempting to use <code>swap_with_slice</code> on a single slice will result in
a compile failure:</p>

<div class='information'><div class='tooltip compile_fail'>ⓘ<span class='tooltiptext'>This example deliberately fails to compile</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered compile_fail">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="ident">slice</span>[..<span class="number">2</span>].<span class="ident">swap_with_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">slice</span>[<span class="number">3</span>..]); <span class="comment">// compile fail!</span></pre></div>
<p>To work around this, we can use <a href="#method.split_at_mut"><code>split_at_mut</code></a> to create two distinct
mutable sub-slices from a slice:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
    <span class="ident">left</span>.<span class="ident">swap_with_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">right</span>[<span class="number">1</span>..]);
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">slice</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]);</pre></div>
</div><h4 id='method.align_to' class="method"><code>pub unsafe fn <a href='#method.align_to' class='fnname'>align_to</a>&lt;U&gt;(&amp;self) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;[U]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;[T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a></code><span class='since' title='Stable since Rust version 1.30.0'>1.30.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2580-2606' title='goto source code'>[src]</a></h4><div class='docblock'><p>Transmute the slice to a slice of another type, ensuring alignment of the types is
maintained.</p>
<p>This method splits the slice into three distinct slices: prefix, correctly aligned middle
slice of a new type, and the suffix slice. The method may make the middle slice the greatest
length possible for a given type and input slice, but only your algorithm's performance
should depend on that, not its correctness. It is permissible for all of the input data to
be returned as the prefix or suffix slice.</p>
<p>This method has no purpose when either input element <code>T</code> or output element <code>U</code> are
zero-sized and will return the original slice without splitting anything.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>This method is essentially a <code>transmute</code> with respect to the elements in the returned
middle slice, so all the usual caveats pertaining to <code>transmute::&lt;T, U&gt;</code> also apply here.</p>
<h1 id="examples-64" class="section-header"><a href="#examples-64">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
    <span class="kw">let</span> (<span class="ident">prefix</span>, <span class="ident">shorts</span>, <span class="ident">suffix</span>) <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">align_to</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
    <span class="comment">// less_efficient_algorithm_for_bytes(prefix);</span>
    <span class="comment">// more_efficient_algorithm_for_aligned_shorts(shorts);</span>
    <span class="comment">// less_efficient_algorithm_for_bytes(suffix);</span>
}</pre></div>
</div><h4 id='method.align_to_mut' class="method"><code>pub unsafe fn <a href='#method.align_to_mut' class='fnname'>align_to_mut</a>&lt;U&gt;(&amp;mut self) -&gt; <a class="primitive" href="../std/primitive.tuple.html">(</a><a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [U]</a>, <a class="primitive" href="../std/primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../std/primitive.tuple.html">)</a></code><span class='since' title='Stable since Rust version 1.30.0'>1.30.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2639-2667' title='goto source code'>[src]</a></h4><div class='docblock'><p>Transmute the slice to a slice of another type, ensuring alignment of the types is
maintained.</p>
<p>This method splits the slice into three distinct slices: prefix, correctly aligned middle
slice of a new type, and the suffix slice. The method may make the middle slice the greatest
length possible for a given type and input slice, but only your algorithm's performance
should depend on that, not its correctness. It is permissible for all of the input data to
be returned as the prefix or suffix slice.</p>
<p>This method has no purpose when either input element <code>T</code> or output element <code>U</code> are
zero-sized and will return the original slice without splitting anything.</p>
<h1 id="safety-1" class="section-header"><a href="#safety-1">Safety</a></h1>
<p>This method is essentially a <code>transmute</code> with respect to the elements in the returned
middle slice, so all the usual caveats pertaining to <code>transmute::&lt;T, U&gt;</code> also apply here.</p>
<h1 id="examples-65" class="section-header"><a href="#examples-65">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
    <span class="kw">let</span> (<span class="ident">prefix</span>, <span class="ident">shorts</span>, <span class="ident">suffix</span>) <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">align_to_mut</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>();
    <span class="comment">// less_efficient_algorithm_for_bytes(prefix);</span>
    <span class="comment">// more_efficient_algorithm_for_aligned_shorts(shorts);</span>
    <span class="comment">// less_efficient_algorithm_for_bytes(suffix);</span>
}</pre></div>
</div><h4 id='method.is_sorted' class="method"><code>pub fn <a href='#method.is_sorted' class='fnname'>is_sorted</a>(&amp;self) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#2692-2697' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>is_sorted</code>)</summary><p>new API</p>
</details></div></div><div class='docblock'><p>Checks if the elements of this slice are sorted.</p>
<p>That is, for each element <code>a</code> and its following element <code>b</code>, <code>a &lt;= b</code> must hold. If the
slice yields exactly zero or one element, <code>true</code> is returned.</p>
<p>Note that if <code>Self::Item</code> is only <code>PartialOrd</code>, but not <code>Ord</code>, the above definition
implies that this function returns <code>false</code> if any two consecutive items are not
comparable.</p>
<h1 id="examples-66" class="section-header"><a href="#examples-66">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">is_sorted</span>)]</span>
<span class="kw">let</span> <span class="ident">empty</span>: [<span class="ident">i32</span>; <span class="number">0</span>] <span class="op">=</span> [];

<span class="macro">assert</span><span class="macro">!</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>].<span class="ident">is_sorted</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span>[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>].<span class="ident">is_sorted</span>());
<span class="macro">assert</span><span class="macro">!</span>([<span class="number">0</span>].<span class="ident">is_sorted</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">empty</span>.<span class="ident">is_sorted</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span>[<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="ident">f32</span>::<span class="ident">NAN</span>].<span class="ident">is_sorted</span>());</pre></div>
</div><h4 id='method.is_sorted_by' class="method"><code>pub fn <a href='#method.is_sorted_by' class='fnname'>is_sorted_by</a>&lt;F&gt;(&amp;self, compare: F) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T, <a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="enum" href="../core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="../core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#2707-2712' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>is_sorted</code>)</summary><p>new API</p>
</details></div></div><div class='docblock'><p>Checks if the elements of this slice are sorted using the given comparator function.</p>
<p>Instead of using <code>PartialOrd::partial_cmp</code>, this function uses the given <code>compare</code>
function to determine the ordering of two elements. Apart from that, it's equivalent to
<a href="#method.is_sorted"><code>is_sorted</code></a>; see its documentation for more information.</p>
</div><h4 id='method.is_sorted_by_key' class="method"><code>pub fn <a href='#method.is_sorted_by_key' class='fnname'>is_sorted_by_key</a>&lt;F, K&gt;(&amp;self, f: F) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; K,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;K&gt;,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#2732-2738' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>is_sorted</code>)</summary><p>new API</p>
</details></div></div><div class='docblock'><p>Checks if the elements of this slice are sorted using the given key extraction function.</p>
<p>Instead of comparing the slice's elements directly, this function compares the keys of the
elements, as determined by <code>f</code>. Apart from that, it's equivalent to <a href="#method.is_sorted"><code>is_sorted</code></a>; see its
documentation for more information.</p>
<h1 id="examples-67" class="section-header"><a href="#examples-67">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">is_sorted</span>)]</span>

<span class="macro">assert</span><span class="macro">!</span>([<span class="string">&quot;c&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;aaa&quot;</span>].<span class="ident">is_sorted_by_key</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> <span class="ident">s</span>.<span class="ident">len</span>()));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span>[<span class="op">-</span><span class="number">2i32</span>, <span class="op">-</span><span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>].<span class="ident">is_sorted_by_key</span>(<span class="op">|</span><span class="ident">n</span><span class="op">|</span> <span class="ident">n</span>.<span class="ident">abs</span>()));</pre></div>
</div><h4 id='method.partition_point' class="method"><code>pub fn <a href='#method.partition_point' class='fnname'>partition_point</a>&lt;P&gt;(&amp;self, pred: P) -&gt; <a class="primitive" href="../std/primitive.usize.html">usize</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../src/core/slice/mod.rs.html#2765-2792' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>partition_point</code>)</summary><p>new API</p>
</details></div></div><div class='docblock'><p>Returns the index of the partition point according to the given predicate
(the index of the first element of the second partition).</p>
<p>The slice is assumed to be partitioned according to the given predicate.
This means that all elements for which the predicate returns true are at the start of the slice
and all elements for which the predicate returns false are at the end.
For example, [7, 15, 3, 5, 4, 12, 6] is a partitioned under the predicate x % 2 != 0
(all odd numbers are at the start, all even at the end).</p>
<p>If this slice is not partitioned, the returned result is unspecified and meaningless,
as this method performs a kind of binary search.</p>
<h1 id="examples-68" class="section-header"><a href="#examples-68">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#![<span class="ident">feature</span>(<span class="ident">partition_point</span>)]</span>

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
<span class="kw">let</span> <span class="ident">i</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">partition_point</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">5</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">i</span>, <span class="number">4</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>[..<span class="ident">i</span>].<span class="ident">iter</span>().<span class="ident">all</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span> <span class="op">&lt;</span> <span class="number">5</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>[<span class="ident">i</span>..].<span class="ident">iter</span>().<span class="ident">all</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span><span class="op">|</span> <span class="op">!</span>(<span class="ident">x</span> <span class="op">&lt;</span> <span class="number">5</span>)));</pre></div>
</div></div><div class='impl-items'><h4 id='method.is_ascii' class="method"><code>pub fn <a href='#method.is_ascii' class='fnname'>is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2801-2803' title='goto source code'>[src]</a></h4><div class='docblock'><p>Checks if all bytes in this slice are within the ASCII range.</p>
</div><h4 id='method.eq_ignore_ascii_case' class="method"><code>pub fn <a href='#method.eq_ignore_ascii_case' class='fnname'>eq_ignore_ascii_case</a>(&amp;self, other: <a class="primitive" href="../std/primitive.slice.html">&amp;[</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a>) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2811-2813' title='goto source code'>[src]</a></h4><div class='docblock'><p>Checks that two slices are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
</div><h4 id='method.make_ascii_uppercase' class="method"><code>pub fn <a href='#method.make_ascii_uppercase' class='fnname'>make_ascii_uppercase</a>(&amp;mut self)</code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2826-2830' title='goto source code'>[src]</a></h4><div class='docblock'><p>Converts this slice to its ASCII upper case equivalent in-place.</p>
<p>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',
but non-ASCII letters are unchanged.</p>
<p>To return a new uppercased value without modifying the existing one, use
<a href="#method.to_ascii_uppercase"><code>to_ascii_uppercase</code></a>.</p>
</div><h4 id='method.make_ascii_lowercase' class="method"><code>pub fn <a href='#method.make_ascii_lowercase' class='fnname'>make_ascii_lowercase</a>(&amp;mut self)</code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='../src/core/slice/mod.rs.html#2843-2847' title='goto source code'>[src]</a></h4><div class='docblock'><p>Converts this slice to its ASCII lower case equivalent in-place.</p>
<p>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',
but non-ASCII letters are unchanged.</p>
<p>To return a new lowercased value without modifying the existing one, use
<a href="#method.to_ascii_lowercase"><code>to_ascii_lowercase</code></a>.</p>
</div></div><div class='impl-items'><h4 id='method.sort' class="method"><code>pub fn <a href='#method.sort' class='fnname'>sort</a>(&amp;mut self) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/alloc/slice.rs.html#194-199' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sorts the slice.</p>
<p>This sort is stable (i.e., does not reorder equal elements) and <code>O(n * log(n))</code> worst-case.</p>
<p>When applicable, unstable sorting is preferred because it is generally faster than stable
sorting and it doesn't allocate auxiliary memory.
See <a href="#method.sort_unstable"><code>sort_unstable</code></a>.</p>
<h1 id="current-implementation-6" class="section-header"><a href="#current-implementation-6">Current implementation</a></h1>
<p>The current algorithm is an adaptive, iterative merge sort inspired by
<a href="https://en.wikipedia.org/wiki/Timsort">timsort</a>.
It is designed to be very fast in cases where the slice is nearly sorted, or consists of
two or more sorted sequences concatenated one after another.</p>
<p>Also, it allocates temporary storage half the size of <code>self</code>, but for short slices a
non-allocating insertion sort is used instead.</p>
<h1 id="examples-69" class="section-header"><a href="#examples-69">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="ident">v</span>.<span class="ident">sort</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="op">-</span><span class="number">5</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</pre></div>
</div><h4 id='method.sort_by' class="method"><code>pub fn <a href='#method.sort_by' class='fnname'>sort_by</a>&lt;F&gt;(&amp;mut self, compare: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T, <a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; <a class="enum" href="../core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/alloc/slice.rs.html#248-253' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sorts the slice with a comparator function.</p>
<p>This sort is stable (i.e., does not reorder equal elements) and <code>O(n * log(n))</code> worst-case.</p>
<p>The comparator function must define a total ordering for the elements in the slice. If
the ordering is not total, the order of the elements is unspecified. An order is a
total order if it is (for all <code>a</code>, <code>b</code> and <code>c</code>):</p>
<ul>
<li>total and antisymmetric: exactly one of <code>a &lt; b</code>, <code>a == b</code> or <code>a &gt; b</code> is true, and</li>
<li>transitive, <code>a &lt; b</code> and <code>b &lt; c</code> implies <code>a &lt; c</code>. The same must hold for both <code>==</code> and <code>&gt;</code>.</li>
</ul>
<p>For example, while <a href="../std/primitive.f64.html" title="`f64`"><code>f64</code></a> doesn't implement <a href="../core/cmp/trait.Ord.html" title="`Ord`"><code>Ord</code></a> because <code>NaN != NaN</code>, we can use
<code>partial_cmp</code> as our sort function when we know the slice doesn't contain a <code>NaN</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">floats</span> <span class="op">=</span> [<span class="number">5f64</span>, <span class="number">4.0</span>, <span class="number">1.0</span>, <span class="number">3.0</span>, <span class="number">2.0</span>];
<span class="ident">floats</span>.<span class="ident">sort_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">a</span>.<span class="ident">partial_cmp</span>(<span class="ident">b</span>).<span class="ident">unwrap</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">floats</span>, [<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>]);</pre></div>
<p>When applicable, unstable sorting is preferred because it is generally faster than stable
sorting and it doesn't allocate auxiliary memory.
See <a href="#method.sort_unstable_by"><code>sort_unstable_by</code></a>.</p>
<h1 id="current-implementation-7" class="section-header"><a href="#current-implementation-7">Current implementation</a></h1>
<p>The current algorithm is an adaptive, iterative merge sort inspired by
<a href="https://en.wikipedia.org/wiki/Timsort">timsort</a>.
It is designed to be very fast in cases where the slice is nearly sorted, or consists of
two or more sorted sequences concatenated one after another.</p>
<p>Also, it allocates temporary storage half the size of <code>self</code>, but for short slices a
non-allocating insertion sort is used instead.</p>
<h1 id="examples-70" class="section-header"><a href="#examples-70">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>];
<span class="ident">v</span>.<span class="ident">sort_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">a</span>.<span class="ident">cmp</span>(<span class="ident">b</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="comment">// reverse sorting</span>
<span class="ident">v</span>.<span class="ident">sort_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">b</span>.<span class="ident">cmp</span>(<span class="ident">a</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</pre></div>
</div><h4 id='method.sort_by_key' class="method"><code>pub fn <a href='#method.sort_by_key' class='fnname'>sort_by_key</a>&lt;K, F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; K,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.7.0'>1.7.0</span><a class='srclink' href='../src/alloc/slice.rs.html#288-294' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sorts the slice with a key extraction function.</p>
<p>This sort is stable (i.e., does not reorder equal elements) and <code>O(m * n * log(n))</code>
worst-case, where the key function is <code>O(m)</code>.</p>
<p>For expensive key functions (e.g. functions that are not simple property accesses or
basic operations), <a href="#method.sort_by_cached_key"><code>sort_by_cached_key</code></a> is likely to be
significantly faster, as it does not recompute element keys.</p>
<p>When applicable, unstable sorting is preferred because it is generally faster than stable
sorting and it doesn't allocate auxiliary memory.
See <a href="#method.sort_unstable_by_key"><code>sort_unstable_by_key</code></a>.</p>
<h1 id="current-implementation-8" class="section-header"><a href="#current-implementation-8">Current implementation</a></h1>
<p>The current algorithm is an adaptive, iterative merge sort inspired by
<a href="https://en.wikipedia.org/wiki/Timsort">timsort</a>.
It is designed to be very fast in cases where the slice is nearly sorted, or consists of
two or more sorted sequences concatenated one after another.</p>
<p>Also, it allocates temporary storage half the size of <code>self</code>, but for short slices a
non-allocating insertion sort is used instead.</p>
<h1 id="examples-71" class="section-header"><a href="#examples-71">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5i32</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="ident">v</span>.<span class="ident">sort_by_key</span>(<span class="op">|</span><span class="ident">k</span><span class="op">|</span> <span class="ident">k</span>.<span class="ident">abs</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">4</span>, <span class="op">-</span><span class="number">5</span>]);</pre></div>
</div><h4 id='method.sort_by_cached_key' class="method"><code>pub fn <a href='#method.sort_by_cached_key' class='fnname'>sort_by_cached_key</a>&lt;K, F&gt;(&amp;mut self, f: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.reference.html">&amp;</a>T) -&gt; K,<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.34.0'>1.34.0</span><a class='srclink' href='../src/alloc/slice.rs.html#330-374' title='goto source code'>[src]</a></h4><div class='docblock'><p>Sorts the slice with a key extraction function.</p>
<p>During sorting, the key function is called only once per element.</p>
<p>This sort is stable (i.e., does not reorder equal elements) and <code>O(m * n + n * log(n))</code>
worst-case, where the key function is <code>O(m)</code>.</p>
<p>For simple key functions (e.g., functions that are property accesses or
basic operations), <a href="#method.sort_by_key"><code>sort_by_key</code></a> is likely to be
faster.</p>
<h1 id="current-implementation-9" class="section-header"><a href="#current-implementation-9">Current implementation</a></h1>
<p>The current algorithm is based on <a href="https://github.com/orlp/pdqsort">pattern-defeating quicksort</a> by Orson Peters,
which combines the fast average case of randomized quicksort with the fast worst case of
heapsort, while achieving linear time on slices with certain patterns. It uses some
randomization to avoid degenerate cases, but with a fixed seed to always provide
deterministic behavior.</p>
<p>In the worst case, the algorithm allocates temporary storage in a <code>Vec&lt;(K, usize)&gt;</code> the
length of the slice.</p>
<h1 id="examples-72" class="section-header"><a href="#examples-72">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5i32</span>, <span class="number">4</span>, <span class="number">32</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="ident">v</span>.<span class="ident">sort_by_cached_key</span>(<span class="op">|</span><span class="ident">k</span><span class="op">|</span> <span class="ident">k</span>.<span class="ident">to_string</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="op">-</span><span class="number">3</span>, <span class="op">-</span><span class="number">5</span>, <span class="number">2</span>, <span class="number">32</span>, <span class="number">4</span>]);</pre></div>
</div><h4 id='method.to_vec' class="method"><code>pub fn <a href='#method.to_vec' class='fnname'>to_vec</a>(&amp;self) -&gt; <a class="struct" href="../alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/alloc/slice.rs.html#388-394' title='goto source code'>[src]</a></h4><div class='docblock'><p>Copies <code>self</code> into a new <code>Vec</code>.</p>
<h1 id="examples-73" class="section-header"><a href="#examples-73">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">to_vec</span>();
<span class="comment">// Here, `s` and `x` can be modified independently.</span></pre></div>
</div><h4 id='method.repeat' class="method"><code>pub fn <a href='#method.repeat' class='fnname'>repeat</a>(&amp;self, n: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.40.0'>1.40.0</span><a class='srclink' href='../src/alloc/slice.rs.html#438-494' title='goto source code'>[src]</a></h4><div class='docblock'><p>Creates a vector by repeating a slice <code>n</code> times.</p>
<h1 id="panics-21" class="section-header"><a href="#panics-21">Panics</a></h1>
<p>This function will panic if the capacity would overflow.</p>
<h1 id="examples-74" class="section-header"><a href="#examples-74">Examples</a></h1>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>([<span class="number">1</span>, <span class="number">2</span>].<span class="ident">repeat</span>(<span class="number">3</span>), <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]);</pre></div>
<p>A panic upon overflow:</p>

<div class='information'><div class='tooltip should_panic'>ⓘ<span class='tooltiptext'>This example panics</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic">
<span class="comment">// this will panic at runtime</span>
<span class="string">b&quot;0123456789abcdef&quot;</span>.<span class="ident">repeat</span>(<span class="ident">usize</span>::<span class="ident">MAX</span>);</pre></div>
</div><h4 id='method.concat' class="method"><code>pub fn <a href='#method.concat' class='fnname'>concat</a>&lt;Item&gt;(&amp;self) -&gt; &lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a> as <a class="trait" href="../alloc/slice/trait.Concat.html" title="trait alloc::slice::Concat">Concat</a>&lt;Item&gt;&gt;::<a class="type" href="../alloc/slice/trait.Concat.html#associatedtype.Output" title="type alloc::slice::Concat::Output">Output</a><span class="important-traits"><span class="important-traits-tooltip">ⓘ<div class='important-traits-tooltiptext'><span class="docblock"><h3 class="important">Important traits for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></h3><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Item: ?<a class="trait" href="../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>: <a class="trait" href="../alloc/slice/trait.Concat.html" title="trait alloc::slice::Concat">Concat</a>&lt;Item&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/alloc/slice.rs.html#505-510' title='goto source code'>[src]</a></h4><div class='docblock'><p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>.</p>
<h1 id="examples-75" class="section-header"><a href="#examples-75">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>].<span class="ident">concat</span>(), <span class="string">&quot;helloworld&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].<span class="ident">concat</span>(), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</pre></div>
</div><h4 id='method.join' class="method"><code>pub fn <a href='#method.join' class='fnname'>join</a>&lt;Separator&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;sep: Separator<br>) -&gt; &lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a> as <a class="trait" href="../alloc/slice/trait.Join.html" title="trait alloc::slice::Join">Join</a>&lt;Separator&gt;&gt;::<a class="type" href="../alloc/slice/trait.Join.html#associatedtype.Output" title="type alloc::slice::Join::Output">Output</a><span class="important-traits"><span class="important-traits-tooltip">ⓘ<div class='important-traits-tooltiptext'><span class="docblock"><h3 class="important">Important traits for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></h3><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>: <a class="trait" href="../alloc/slice/trait.Join.html" title="trait alloc::slice::Join">Join</a>&lt;Separator&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.3.0'>1.3.0</span><a class='srclink' href='../src/alloc/slice.rs.html#523-528' title='goto source code'>[src]</a></h4><div class='docblock'><p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>, placing a
given separator between each.</p>
<h1 id="examples-76" class="section-header"><a href="#examples-76">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>].<span class="ident">join</span>(<span class="string">&quot; &quot;</span>), <span class="string">&quot;hello world&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].<span class="ident">join</span>(<span class="kw-2">&amp;</span><span class="number">0</span>), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].<span class="ident">join</span>(<span class="kw-2">&amp;</span>[<span class="number">0</span>, <span class="number">0</span>][..]), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>]);</pre></div>
</div><h4 id='method.connect' class="method"><code>pub fn <a href='#method.connect' class='fnname'>connect</a>&lt;Separator&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;sep: Separator<br>) -&gt; &lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a> as <a class="trait" href="../alloc/slice/trait.Join.html" title="trait alloc::slice::Join">Join</a>&lt;Separator&gt;&gt;::<a class="type" href="../alloc/slice/trait.Join.html#associatedtype.Output" title="type alloc::slice::Join::Output">Output</a><span class="important-traits"><span class="important-traits-tooltip">ⓘ<div class='important-traits-tooltiptext'><span class="docblock"><h3 class="important">Important traits for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></h3><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="../std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="primitive" href="../std/primitive.slice.html">&amp;'_ mut [</a><a class="primitive" href="../std/primitive.u8.html">u8</a><a class="primitive" href="../std/primitive.slice.html">]</a></span></code></span></div></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>: <a class="trait" href="../alloc/slice/trait.Join.html" title="trait alloc::slice::Join">Join</a>&lt;Separator&gt;,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/alloc/slice.rs.html#542-547' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab deprecated'><span class='emoji'>👎</span> Deprecated since 1.3.0: <p>renamed to join</p>
</div></div><div class='docblock'><p>Flattens a slice of <code>T</code> into a single value <code>Self::Output</code>, placing a
given separator between each.</p>
<h1 id="examples-77" class="section-header"><a href="#examples-77">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">assert_eq</span><span class="macro">!</span>([<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>].<span class="ident">connect</span>(<span class="string">&quot; &quot;</span>), <span class="string">&quot;hello world&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].<span class="ident">connect</span>(<span class="kw-2">&amp;</span><span class="number">0</span>), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>]);</pre></div>
</div></div><div class='impl-items'><h4 id='method.to_ascii_uppercase' class="method"><code>pub fn <a href='#method.to_ascii_uppercase' class='fnname'>to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="../alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="../std/primitive.u8.html">u8</a>&gt;</code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='../src/alloc/slice.rs.html#564-568' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a vector containing a copy of this slice where each byte
is mapped to its ASCII upper case equivalent.</p>
<p>ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="#method.make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
</div><h4 id='method.to_ascii_lowercase' class="method"><code>pub fn <a href='#method.to_ascii_lowercase' class='fnname'>to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="../alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="../std/primitive.u8.html">u8</a>&gt;</code><span class='since' title='Stable since Rust version 1.23.0'>1.23.0</span><a class='srclink' href='../src/alloc/slice.rs.html#581-585' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a vector containing a copy of this slice where each byte
is mapped to its ASCII lower case equivalent.</p>
<p>ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="#method.make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
</div></div><h2 id='trait-implementations' class='small-section-header'>Trait Implementations<a href='#trait-implementations' class='anchor'></a></h2><div id='trait-implementations-list'><h3 id='impl-Clone' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-Clone' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#60-65' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone' class="method hidden"><code>fn <a href='../core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#62-64' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="../core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method hidden"><code>fn <a href='../core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>Self)</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/clone.rs.html#131-133' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="../core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a>,&nbsp;</span></code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#67-71' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code>fn <a href='../core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, formatter: &amp;mut <a class="struct" href="../core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="../std/primitive.unit.html">()</a>, <a class="struct" href="../core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#68-70' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="../core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Default' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-Default' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#37-46' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.default' class="method hidden"><code>fn <a href='../core/default/trait.Default.html#tymethod.default' class='fnname'>default</a>() -&gt; <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#39-45' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns the &quot;default value&quot; for a type. <a href="../core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><h3 id='impl-Deref' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-Deref' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#112-119' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Target' class="type"><code>type <a href='../core/ops/deref/trait.Deref.html#associatedtype.Target' class="type">Target</a> = <a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a></code></h4><div class='docblock'><p>The resulting type after dereferencing.</p>
</div><h4 id='method.deref' class="method hidden"><code>fn <a href='../core/ops/deref/trait.Deref.html#tymethod.deref' class='fnname'>deref</a>(&amp;self) -&gt; &amp;&lt;<a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; as <a class="trait" href="../core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&gt;::<a class="type" href="../core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#116-118' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Dereferences the value.</p>
</div></div><h3 id='impl-DerefMut' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-DerefMut' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#121-126' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.deref_mut' class="method hidden"><code>fn <a href='../core/ops/deref/trait.DerefMut.html#tymethod.deref_mut' class='fnname'>deref_mut</a>(&amp;mut self) -&gt; &amp;mut &lt;<a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; as <a class="trait" href="../core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&gt;::<a class="type" href="../core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#123-125' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably dereferences the value.</p>
</div></div><h3 id='impl-Deserialize%3C%27de%3E' class='impl'><code class='in-band'>impl&lt;'de, T&gt; <a class="trait" href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize">Deserialize</a>&lt;'de&gt; for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize">Deserialize</a>&lt;'de&gt;,&nbsp;</span></code><a href='#impl-Deserialize%3C%27de%3E' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#186-194' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.deserialize' class="method hidden"><code>fn <a href='../serde/de/trait.Deserialize.html#tymethod.deserialize' class='fnname'>deserialize</a>&lt;D&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;deserializer: D<br>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;, &lt;D as <a class="trait" href="../serde/de/trait.Deserializer.html" title="trait serde::de::Deserializer">Deserializer</a>&lt;'de&gt;&gt;::<a class="type" href="../serde/de/trait.Deserializer.html#associatedtype.Error" title="type serde::de::Deserializer::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;D: <a class="trait" href="../serde/de/trait.Deserializer.html" title="trait serde::de::Deserializer">Deserializer</a>&lt;'de&gt;,&nbsp;</span></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#187-193' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Deserialize this value from the given Serde deserializer. <a href="../serde/de/trait.Deserialize.html#tymethod.deserialize">Read more</a></p>
</div></div><h3 id='impl-Drop' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-Drop' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#48-55' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.drop' class="method hidden"><code>fn <a href='../core/ops/drop/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#50-54' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Executes the destructor for this type. <a href="../core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></div><h3 id='impl-Eq' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a>,&nbsp;</span></code><a href='#impl-Eq' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#79' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-From%3CBox%3C%5BT%5D%3E%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;&gt; for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-From%3CBox%3C%5BT%5D%3E%3E' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#128-140' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-1' class="method hidden"><code>fn <a href='../core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(b: <a class="struct" href="../alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="../std/primitive.slice.html">[</a>T<a class="primitive" href="../std/primitive.slice.html">]</a>&gt;) -&gt; <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#130-139' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3COwnedSlice%3CGenericBoxShadow%3CGenericColor%3CRGBA%3E%2C%20CSSPixelLength%2C%20NonNegative%3CCSSPixelLength%3E%2C%20CSSPixelLength%3E%3E%3E' class='impl'><code class='in-band'>impl <a class="trait" href="../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;<a class="struct" href="../style/values/generics/effects/struct.GenericBoxShadow.html" title="struct style::values::generics::effects::GenericBoxShadow">GenericBoxShadow</a>&lt;<a class="enum" href="../style/values/generics/color/enum.GenericColor.html" title="enum style::values::generics::color::GenericColor">GenericColor</a>&lt;<a class="struct" href="../style/values/struct.RGBA.html" title="struct style::values::RGBA">RGBA</a>&gt;, <a class="struct" href="../style/values/computed/length/struct.CSSPixelLength.html" title="struct style::values::computed::length::CSSPixelLength">CSSPixelLength</a>, <a class="struct" href="../style/values/generics/struct.NonNegative.html" title="struct style::values::generics::NonNegative">NonNegative</a>&lt;<a class="struct" href="../style/values/computed/length/struct.CSSPixelLength.html" title="struct style::values::computed::length::CSSPixelLength">CSSPixelLength</a>&gt;, <a class="struct" href="../style/values/computed/length/struct.CSSPixelLength.html" title="struct style::values::computed::length::CSSPixelLength">CSSPixelLength</a>&gt;&gt;&gt; for <a class="type" href="../style/properties/longhands/box_shadow/computed_value/type.ComputedList.html" title="type style::properties::longhands::box_shadow::computed_value::ComputedList">ComputedList</a></code><a href='#impl-From%3COwnedSlice%3CGenericBoxShadow%3CGenericColor%3CRGBA%3E%2C%20CSSPixelLength%2C%20NonNegative%3CCSSPixelLength%3E%2C%20CSSPixelLength%3E%3E%3E' class='anchor'></a><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/longhands/effects.rs.html#260-265' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-2' class="method hidden"><code>fn <a href='../core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(l: <a class="type" href="../style/properties/longhands/box_shadow/computed_value/type.UnderlyingList.html" title="type style::properties::longhands::box_shadow::computed_value::UnderlyingList">UnderlyingList</a>&lt;<a class="type" href="../style/values/computed/effects/type.BoxShadow.html" title="type style::values::computed::effects::BoxShadow">T</a>&gt;) -&gt; Self</code><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/longhands/effects.rs.html#262-264' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3COwnedSlice%3CGenericFilter%3CAngle%2C%20NonNegative%3Cf32%3E%2C%20ZeroToOne%3Cf32%3E%2C%20NonNegative%3CCSSPixelLength%3E%2C%20Impossible%2C%20Impossible%3E%3E%3E' class='impl'><code class='in-band'>impl <a class="trait" href="../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;<a class="enum" href="../style/values/generics/effects/enum.GenericFilter.html" title="enum style::values::generics::effects::GenericFilter">GenericFilter</a>&lt;<a class="struct" href="../style/values/computed/angle/struct.Angle.html" title="struct style::values::computed::angle::Angle">Angle</a>, <a class="struct" href="../style/values/generics/struct.NonNegative.html" title="struct style::values::generics::NonNegative">NonNegative</a>&lt;<a class="primitive" href="../std/primitive.f32.html">f32</a>&gt;, <a class="struct" href="../style/values/generics/struct.ZeroToOne.html" title="struct style::values::generics::ZeroToOne">ZeroToOne</a>&lt;<a class="primitive" href="../std/primitive.f32.html">f32</a>&gt;, <a class="struct" href="../style/values/generics/struct.NonNegative.html" title="struct style::values::generics::NonNegative">NonNegative</a>&lt;<a class="struct" href="../style/values/computed/length/struct.CSSPixelLength.html" title="struct style::values::computed::length::CSSPixelLength">CSSPixelLength</a>&gt;, <a class="enum" href="../style/values/enum.Impossible.html" title="enum style::values::Impossible">Impossible</a>, <a class="enum" href="../style/values/enum.Impossible.html" title="enum style::values::Impossible">Impossible</a>&gt;&gt;&gt; for <a class="type" href="../style/properties/longhands/filter/computed_value/type.ComputedList.html" title="type style::properties::longhands::filter::computed_value::ComputedList">ComputedList</a></code><a href='#impl-From%3COwnedSlice%3CGenericFilter%3CAngle%2C%20NonNegative%3Cf32%3E%2C%20ZeroToOne%3Cf32%3E%2C%20NonNegative%3CCSSPixelLength%3E%2C%20Impossible%2C%20Impossible%3E%3E%3E' class='anchor'></a><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/longhands/effects.rs.html#656-661' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-3' class="method hidden"><code>fn <a href='../core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(l: <a class="type" href="../style/properties/longhands/filter/computed_value/type.UnderlyingList.html" title="type style::properties::longhands::filter::computed_value::UnderlyingList">UnderlyingList</a>&lt;<a class="type" href="../style/values/computed/effects/type.Filter.html" title="type style::values::computed::effects::Filter">T</a>&gt;) -&gt; Self</code><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/longhands/effects.rs.html#658-660' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3CVec%3CT%3E%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-From%3CVec%3CT%3E%3E' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#142-147' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code>fn <a href='../core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(b: <a class="struct" href="../alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#144-146' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-FromIterator%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;T&gt; for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-FromIterator%3CT%3E' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#170-175' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from_iter' class="method hidden"><code>fn <a href='../core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter' class='fnname'>from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = T&gt;,&nbsp;</span></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#172-174' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates a value from an iterator. <a href="../core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></p>
</div></div><h3 id='impl-ListAnimation%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../style/properties/animated_properties/trait.ListAnimation.html" title="trait style::properties::animated_properties::ListAnimation">ListAnimation</a>&lt;T&gt; for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-ListAnimation%3CT%3E' class='anchor'></a><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#16007-16090' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.animate_repeatable_list' class="method hidden"><code>fn <a href='../style/properties/animated_properties/trait.ListAnimation.html#tymethod.animate_repeatable_list' class='fnname'>animate_repeatable_list</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;other: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>Self, <br>&nbsp;&nbsp;&nbsp;&nbsp;procedure: <a class="enum" href="../style/values/animated/enum.Procedure.html" title="enum style::values::animated::Procedure">Procedure</a><br>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="primitive" href="../std/primitive.unit.html">()</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style/values/animated/trait.Animate.html" title="trait style::values::animated::Animate">Animate</a>,&nbsp;</span></code><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#16008-16025' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>https://drafts.csswg.org/css-transitions/#animtype-repeatable-list</p>
</div><h4 id='method.squared_distance_repeatable_list' class="method hidden"><code>fn <a href='../style/properties/animated_properties/trait.ListAnimation.html#tymethod.squared_distance_repeatable_list' class='fnname'>squared_distance_repeatable_list</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;other: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>Self<br>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../style/values/distance/struct.SquaredDistance.html" title="struct style::values::distance::SquaredDistance">SquaredDistance</a>, <a class="primitive" href="../std/primitive.unit.html">()</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style/values/distance/trait.ComputeSquaredDistance.html" title="trait style::values::distance::ComputeSquaredDistance">ComputeSquaredDistance</a>,&nbsp;</span></code><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#16027-16042' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>https://drafts.csswg.org/css-transitions/#animtype-repeatable-list</p>
</div><h4 id='method.animate_with_zero' class="method hidden"><code>fn <a href='../style/properties/animated_properties/trait.ListAnimation.html#tymethod.animate_with_zero' class='fnname'>animate_with_zero</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;other: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>Self, <br>&nbsp;&nbsp;&nbsp;&nbsp;procedure: <a class="enum" href="../style/values/animated/enum.Procedure.html" title="enum style::values::animated::Procedure">Procedure</a><br>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="primitive" href="../std/primitive.unit.html">()</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style/values/animated/trait.Animate.html" title="trait style::values::animated::Animate">Animate</a> + <a class="trait" href="../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="../style/values/animated/trait.ToAnimatedZero.html" title="trait style::values::animated::ToAnimatedZero">ToAnimatedZero</a>,&nbsp;</span></code><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#16044-16070' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This is the animation used for some of the types like shadows and filters, where the interpolation happens with the zero value if one of the sides is not present. <a href="../style/properties/animated_properties/trait.ListAnimation.html#tymethod.animate_with_zero">Read more</a></p>
</div><h4 id='method.squared_distance_with_zero' class="method hidden"><code>fn <a href='../style/properties/animated_properties/trait.ListAnimation.html#tymethod.squared_distance_with_zero' class='fnname'>squared_distance_with_zero</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;other: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>Self<br>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../style/values/distance/struct.SquaredDistance.html" title="struct style::values::distance::SquaredDistance">SquaredDistance</a>, <a class="primitive" href="../std/primitive.unit.html">()</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style/values/animated/trait.ToAnimatedZero.html" title="trait style::values::animated::ToAnimatedZero">ToAnimatedZero</a> + <a class="trait" href="../style/values/distance/trait.ComputeSquaredDistance.html" title="trait style::values::distance::ComputeSquaredDistance">ComputeSquaredDistance</a>,&nbsp;</span></code><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#16072-16089' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This is the animation used for some of the types like shadows and filters, where the interpolation happens with the zero value if one of the sides is not present. <a href="../style/properties/animated_properties/trait.ListAnimation.html#tymethod.squared_distance_with_zero">Read more</a></p>
</div></div><h3 id='impl-MallocShallowSizeOf' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../malloc_size_of/trait.MallocShallowSizeOf.html" title="trait malloc_size_of::MallocShallowSizeOf">MallocShallowSizeOf</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;</code><a href='#impl-MallocShallowSizeOf' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#149-153' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.shallow_size_of' class="method hidden"><code>fn <a href='../malloc_size_of/trait.MallocShallowSizeOf.html#tymethod.shallow_size_of' class='fnname'>shallow_size_of</a>(&amp;self, ops: &amp;mut <a class="struct" href="../malloc_size_of/struct.MallocSizeOfOps.html" title="struct malloc_size_of::MallocSizeOfOps">MallocSizeOfOps</a>) -&gt; <a class="primitive" href="../std/primitive.usize.html">usize</a></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#150-152' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Measure the heap usage of immediate heap-allocated descendant structures, but not the space taken up by the value itself. Anything beyond the immediate descendants must be measured separately, using iteration. <a href="../malloc_size_of/trait.MallocShallowSizeOf.html#tymethod.shallow_size_of">Read more</a></p>
</div></div><h3 id='impl-MallocSizeOf' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../malloc_size_of/trait.MallocSizeOf.html" title="trait malloc_size_of::MallocSizeOf">MallocSizeOf</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../malloc_size_of/trait.MallocSizeOf.html" title="trait malloc_size_of::MallocSizeOf">MallocSizeOf</a>,&nbsp;</span></code><a href='#impl-MallocSizeOf' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#155-159' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.size_of' class="method hidden"><code>fn <a href='../malloc_size_of/trait.MallocSizeOf.html#tymethod.size_of' class='fnname'>size_of</a>(&amp;self, ops: &amp;mut <a class="struct" href="../malloc_size_of/struct.MallocSizeOfOps.html" title="struct malloc_size_of::MallocSizeOfOps">MallocSizeOfOps</a>) -&gt; <a class="primitive" href="../std/primitive.usize.html">usize</a></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#156-158' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Measure the heap usage of all descendant heap-allocated structures, but not the space taken up by the value itself. <a href="../malloc_size_of/trait.MallocSizeOf.html#tymethod.size_of">Read more</a></p>
</div></div><h3 id='impl-PartialEq%3COwnedSlice%3CT%3E%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;&gt; for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-PartialEq%3COwnedSlice%3CT%3E%3E' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#73-77' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq' class="method hidden"><code>fn <a href='../core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#74-76' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne' class="method hidden"><code><span class="docblock attributes">#[must_use]</span>fn <a href='../core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a></code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='../src/core/cmp.rs.html#215-217' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></code><a href='#impl-Send' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#57' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Serialize' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize">Serialize</a>,&nbsp;</span></code><a href='#impl-Serialize' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#177-184' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.serialize' class="method hidden"><code>fn <a href='../serde/ser/trait.Serialize.html#tymethod.serialize' class='fnname'>serialize</a>&lt;S&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;serializer: S<br>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&lt;S as <a class="trait" href="../serde/ser/trait.Serializer.html" title="trait serde::ser::Serializer">Serializer</a>&gt;::<a class="type" href="../serde/ser/trait.Serializer.html#associatedtype.Ok" title="type serde::ser::Serializer::Ok">Ok</a>, &lt;S as <a class="trait" href="../serde/ser/trait.Serializer.html" title="trait serde::ser::Serializer">Serializer</a>&gt;::<a class="type" href="../serde/ser/trait.Serializer.html#associatedtype.Error" title="type serde::ser::Serializer::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: <a class="trait" href="../serde/ser/trait.Serializer.html" title="trait serde::ser::Serializer">Serializer</a>,&nbsp;</span></code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#178-183' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Serialize this value into the given Serde serializer. <a href="../serde/ser/trait.Serialize.html#tymethod.serialize">Read more</a></p>
</div></div><h3 id='impl-SpecifiedValueInfo' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../style_traits/specified_value_info/trait.SpecifiedValueInfo.html" title="trait style_traits::specified_value_info::SpecifiedValueInfo">SpecifiedValueInfo</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style_traits/specified_value_info/trait.SpecifiedValueInfo.html" title="trait style_traits::specified_value_info::SpecifiedValueInfo">SpecifiedValueInfo</a>,&nbsp;</span></code><a href='#impl-SpecifiedValueInfo' class='anchor'></a><a class='srclink' href='../src/style_traits/specified_value_info.rs.html#111-116' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedconstant.SUPPORTED_TYPES' class="associatedconstant hidden"><code>const <a href='../style_traits/specified_value_info/trait.SpecifiedValueInfo.html#associatedconstant.SUPPORTED_TYPES' class="constant"><b>SUPPORTED_TYPES</b></a>: <a class="primitive" href="../std/primitive.u8.html">u8</a></code><a class='srclink' href='../src/style_traits/specified_value_info.rs.html#112' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Supported CssTypes by the given value type. <a href="../style_traits/specified_value_info/trait.SpecifiedValueInfo.html#associatedconstant.SUPPORTED_TYPES">Read more</a></p>
</div><h4 id='method.collect_completion_keywords' class="method hidden"><code>fn <a href='../style_traits/specified_value_info/trait.SpecifiedValueInfo.html#method.collect_completion_keywords' class='fnname'>collect_completion_keywords</a>(f: &amp;mut dyn <a class="trait" href="../core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="../std/primitive.slice.html">&amp;[</a>&amp;'static <a class="primitive" href="../std/primitive.str.html">str</a><a class="primitive" href="../std/primitive.slice.html">]</a>))</code><a class='srclink' href='../src/style_traits/specified_value_info.rs.html#113-115' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Collect value starting words for the given specified value type. This includes keyword and function names which can appear at the beginning of a value of this type. <a href="../style_traits/specified_value_info/trait.SpecifiedValueInfo.html#method.collect_completion_keywords">Read more</a></p>
</div></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></code><a href='#impl-Sync' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#58' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-ToAnimatedValue' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../style/values/animated/trait.ToAnimatedValue.html" title="trait style::values::animated::ToAnimatedValue">ToAnimatedValue</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style/values/animated/trait.ToAnimatedValue.html" title="trait style::values::animated::ToAnimatedValue">ToAnimatedValue</a>,&nbsp;</span></code><a href='#impl-ToAnimatedValue' class='anchor'></a><a class='srclink' href='../src/style/values/animated/mod.rs.html#323-338' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.AnimatedValue' class="type"><code>type <a href='../style/values/animated/trait.ToAnimatedValue.html#associatedtype.AnimatedValue' class="type">AnimatedValue</a> = <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;&lt;T as <a class="trait" href="../style/values/animated/trait.ToAnimatedValue.html" title="trait style::values::animated::ToAnimatedValue">ToAnimatedValue</a>&gt;::<a class="type" href="../style/values/animated/trait.ToAnimatedValue.html#associatedtype.AnimatedValue" title="type style::values::animated::ToAnimatedValue::AnimatedValue">AnimatedValue</a>&gt;</code></h4><div class='docblock'><p>The type of the animated value.</p>
</div><h4 id='method.to_animated_value' class="method hidden"><code>fn <a href='../style/values/animated/trait.ToAnimatedValue.html#tymethod.to_animated_value' class='fnname'>to_animated_value</a>(self) -&gt; Self::<a class="type" href="../style/values/animated/trait.ToAnimatedValue.html#associatedtype.AnimatedValue" title="type style::values::animated::ToAnimatedValue::AnimatedValue">AnimatedValue</a></code><a class='srclink' href='../src/style/values/animated/mod.rs.html#330-332' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Converts this value to an animated value.</p>
</div><h4 id='method.from_animated_value' class="method hidden"><code>fn <a href='../style/values/animated/trait.ToAnimatedValue.html#tymethod.from_animated_value' class='fnname'>from_animated_value</a>(animated: Self::<a class="type" href="../style/values/animated/trait.ToAnimatedValue.html#associatedtype.AnimatedValue" title="type style::values::animated::ToAnimatedValue::AnimatedValue">AnimatedValue</a>) -&gt; Self</code><a class='srclink' href='../src/style/values/animated/mod.rs.html#335-337' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Converts back an animated value into a computed value.</p>
</div></div><h3 id='impl-ToAnimatedZero' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../style/values/animated/trait.ToAnimatedZero.html" title="trait style::values::animated::ToAnimatedZero">ToAnimatedZero</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style/values/animated/trait.ToAnimatedZero.html" title="trait style::values::animated::ToAnimatedZero">ToAnimatedZero</a>,&nbsp;</span></code><a href='#impl-ToAnimatedZero' class='anchor'></a><a class='srclink' href='../src/style/values/animated/mod.rs.html#466-474' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_animated_zero' class="method hidden"><code>fn <a href='../style/values/animated/trait.ToAnimatedZero.html#tymethod.to_animated_zero' class='fnname'>to_animated_zero</a>(&amp;self) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="primitive" href="../std/primitive.unit.html">()</a>&gt;</code><a class='srclink' href='../src/style/values/animated/mod.rs.html#471-473' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a value that, when added with an underlying value, will produce the underlying value. This is used for SMIL animation's &quot;by-animation&quot; where SMIL first interpolates from the zero value to the 'by' value, and then adds the result to the underlying value. <a href="../style/values/animated/trait.ToAnimatedZero.html#tymethod.to_animated_zero">Read more</a></p>
</div></div><h3 id='impl-ToComputedValue' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../style/values/computed/trait.ToComputedValue.html" title="trait style::values::computed::ToComputedValue">ToComputedValue</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style/values/computed/trait.ToComputedValue.html" title="trait style::values::computed::ToComputedValue">ToComputedValue</a>,&nbsp;</span></code><a href='#impl-ToComputedValue' class='anchor'></a><a class='srclink' href='../src/style/values/computed/mod.rs.html#440-457' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.ComputedValue' class="type"><code>type <a href='../style/values/computed/trait.ToComputedValue.html#associatedtype.ComputedValue' class="type">ComputedValue</a> = <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;&lt;T as <a class="trait" href="../style/values/computed/trait.ToComputedValue.html" title="trait style::values::computed::ToComputedValue">ToComputedValue</a>&gt;::<a class="type" href="../style/values/computed/trait.ToComputedValue.html#associatedtype.ComputedValue" title="type style::values::computed::ToComputedValue::ComputedValue">ComputedValue</a>&gt;</code></h4><div class='docblock'><p>The computed value type we're going to be converted to.</p>
</div><h4 id='method.to_computed_value' class="method hidden"><code>fn <a href='../style/values/computed/trait.ToComputedValue.html#tymethod.to_computed_value' class='fnname'>to_computed_value</a>(&amp;self, context: &amp;<a class="struct" href="../style/values/computed/struct.Context.html" title="struct style::values::computed::Context">Context</a>) -&gt; Self::<a class="type" href="../style/values/computed/trait.ToComputedValue.html#associatedtype.ComputedValue" title="type style::values::computed::ToComputedValue::ComputedValue">ComputedValue</a></code><a class='srclink' href='../src/style/values/computed/mod.rs.html#447-451' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Convert a specified value to a computed value, using itself and the data inside the <code>Context</code>. <a href="../style/values/computed/trait.ToComputedValue.html#tymethod.to_computed_value">Read more</a></p>
</div><h4 id='method.from_computed_value' class="method hidden"><code>fn <a href='../style/values/computed/trait.ToComputedValue.html#tymethod.from_computed_value' class='fnname'>from_computed_value</a>(computed: &amp;Self::<a class="type" href="../style/values/computed/trait.ToComputedValue.html#associatedtype.ComputedValue" title="type style::values::computed::ToComputedValue::ComputedValue">ComputedValue</a>) -&gt; Self</code><a class='srclink' href='../src/style/values/computed/mod.rs.html#454-456' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Convert a computed value to specified value form. <a href="../style/values/computed/trait.ToComputedValue.html#tymethod.from_computed_value">Read more</a></p>
</div></div><h3 id='impl-ToResolvedValue' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../style/values/resolved/trait.ToResolvedValue.html" title="trait style::values::resolved::ToResolvedValue">ToResolvedValue</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../style/values/resolved/trait.ToResolvedValue.html" title="trait style::values::resolved::ToResolvedValue">ToResolvedValue</a>,&nbsp;</span></code><a href='#impl-ToResolvedValue' class='anchor'></a><a class='srclink' href='../src/style/values/resolved/mod.rs.html#206-221' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.ResolvedValue' class="type"><code>type <a href='../style/values/resolved/trait.ToResolvedValue.html#associatedtype.ResolvedValue' class="type">ResolvedValue</a> = <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;&lt;T as <a class="trait" href="../style/values/resolved/trait.ToResolvedValue.html" title="trait style::values::resolved::ToResolvedValue">ToResolvedValue</a>&gt;::<a class="type" href="../style/values/resolved/trait.ToResolvedValue.html#associatedtype.ResolvedValue" title="type style::values::resolved::ToResolvedValue::ResolvedValue">ResolvedValue</a>&gt;</code></h4><div class='docblock'><p>The resolved value type we're going to be converted to.</p>
</div><h4 id='method.to_resolved_value' class="method hidden"><code>fn <a href='../style/values/resolved/trait.ToResolvedValue.html#tymethod.to_resolved_value' class='fnname'>to_resolved_value</a>(self, context: &amp;<a class="struct" href="../style/values/resolved/struct.Context.html" title="struct style::values::resolved::Context">Context</a>) -&gt; Self::<a class="type" href="../style/values/resolved/trait.ToResolvedValue.html#associatedtype.ResolvedValue" title="type style::values::resolved::ToResolvedValue::ResolvedValue">ResolvedValue</a></code><a class='srclink' href='../src/style/values/resolved/mod.rs.html#213-215' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Convert a resolved value to a resolved value.</p>
</div><h4 id='method.from_resolved_value' class="method hidden"><code>fn <a href='../style/values/resolved/trait.ToResolvedValue.html#tymethod.from_resolved_value' class='fnname'>from_resolved_value</a>(resolved: Self::<a class="type" href="../style/values/resolved/trait.ToResolvedValue.html#associatedtype.ResolvedValue" title="type style::values::resolved::ToResolvedValue::ResolvedValue">ResolvedValue</a>) -&gt; Self</code><a class='srclink' href='../src/style/values/resolved/mod.rs.html#218-220' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Convert a resolved value to resolved value form.</p>
</div></div><h3 id='impl-ToShmem' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../to_shmem/trait.ToShmem.html" title="trait to_shmem::ToShmem">ToShmem</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../to_shmem/trait.ToShmem.html" title="trait to_shmem::ToShmem">ToShmem</a>,&nbsp;</span></code><a href='#impl-ToShmem' class='anchor'></a><a class='srclink' href='../src/style_traits/owned_slice.rs.html#161-168' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_shmem' class="method hidden"><code>fn <a href='../to_shmem/trait.ToShmem.html#tymethod.to_shmem' class='fnname'>to_shmem</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;builder: &amp;mut <a class="struct" href="../to_shmem/struct.SharedMemoryBuilder.html" title="struct to_shmem::SharedMemoryBuilder">SharedMemoryBuilder</a><br>) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../core/mem/manually_drop/struct.ManuallyDrop.html" title="struct core::mem::manually_drop::ManuallyDrop">ManuallyDrop</a>&lt;<a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt;&gt;, <a class="struct" href="../alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</code><a class='srclink' href='../src/style_traits/owned_slice.rs.html#162-167' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Clones this value into a form suitable for writing into a SharedMemoryBuilder. <a href="../to_shmem/trait.ToShmem.html#tymethod.to_shmem">Read more</a></p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-RefUnwindSafe' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></code><a href='#impl-RefUnwindSafe' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Unpin' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code><a href='#impl-Unpin' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-UnwindSafe' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../style/struct.OwnedSlice.html" title="struct style::OwnedSlice">OwnedSlice</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> + <a class="trait" href="../std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,&nbsp;</span></code><a href='#impl-UnwindSafe' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='../src/core/any.rs.html#108-112' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code>fn <a href='../core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="../core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='../src/core/any.rs.html#109-111' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="../core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='../src/core/borrow.rs.html#213-217' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><code>fn <a href='../core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="../std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='../src/core/borrow.rs.html#214-216' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="../core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='../src/core/borrow.rs.html#220-224' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><code>fn <a href='../core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='../src/core/borrow.rs.html#221-223' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="../core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-DeserializeOwned' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../serde/de/trait.DeserializeOwned.html" title="trait serde::de::DeserializeOwned">DeserializeOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: for&lt;'de&gt; <a class="trait" href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize">Deserialize</a>&lt;'de&gt;,&nbsp;</span></code><a href='#impl-DeserializeOwned' class='anchor'></a><a class='srclink' href='../src/serde/de/mod.rs.html#604' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-Equivalent%3CK%3E' class='impl'><code class='in-band'>impl&lt;Q, K&gt; <a class="trait" href="../indexmap/equivalent/trait.Equivalent.html" title="trait indexmap::equivalent::Equivalent">Equivalent</a>&lt;K&gt; for Q <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;K: <a class="trait" href="../core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Q: <a class="trait" href="../core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + ?<a class="trait" href="../core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Equivalent%3CK%3E' class='anchor'></a><a class='srclink' href='../src/indexmap/equivalent.rs.html#18-27' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.equivalent' class="method hidden"><code>fn <a href='../indexmap/equivalent/trait.Equivalent.html#tymethod.equivalent' class='fnname'>equivalent</a>(&amp;self, key: <a class="primitive" href="../std/primitive.reference.html">&amp;</a>K) -&gt; <a class="primitive" href="../std/primitive.bool.html">bool</a></code><a class='srclink' href='../src/indexmap/equivalent.rs.html#24-26' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Compare self to <code>key</code> and return <code>true</code> if they are equal.</p>
</div></div><h3 id='impl-Erased' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../owning_ref/trait.Erased.html" title="trait owning_ref::Erased">Erased</a> for T</code><a href='#impl-Erased' class='anchor'></a><a class='srclink' href='../src/owning_ref/lib.rs.html#281' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='../src/core/convert/mod.rs.html#569-573' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from-4' class="method hidden"><code>fn <a href='../core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='../src/core/convert/mod.rs.html#570-572' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='../src/core/convert/mod.rs.html#558-565' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code>fn <a href='../core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='../src/core/convert/mod.rs.html#562-564' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-MaybeBoxed%3CBox%3CT%3E%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../style/properties/trait.MaybeBoxed.html" title="trait style::properties::MaybeBoxed">MaybeBoxed</a>&lt;<a class="struct" href="../alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;T&gt;&gt; for T</code><a href='#impl-MaybeBoxed%3CBox%3CT%3E%3E' class='anchor'></a><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#73-76' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.maybe_boxed-1' class="method hidden"><code>fn <a href='../style/properties/trait.MaybeBoxed.html#tymethod.maybe_boxed' class='fnname'>maybe_boxed</a>(Self) -&gt; <a class="struct" href="../alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;T&gt;</code><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#75' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Convert</p>
</div></div><h3 id='impl-MaybeBoxed%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../style/properties/trait.MaybeBoxed.html" title="trait style::properties::MaybeBoxed">MaybeBoxed</a>&lt;T&gt; for T</code><a href='#impl-MaybeBoxed%3CT%3E' class='anchor'></a><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#68-71' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.maybe_boxed' class="method hidden"><code>fn <a href='../style/properties/trait.MaybeBoxed.html#tymethod.maybe_boxed' class='fnname'>maybe_boxed</a>(Self) -&gt; T</code><a class='srclink' href='../src/style/repo/target/debug/build/style-d84e5c3f79a77524/out/properties.rs.html#70' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Convert</p>
</div></div><h3 id='impl-Pointable' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a> for T</code><a href='#impl-Pointable' class='anchor'></a><a class='srclink' href='../src/crossbeam_epoch/atomic.rs.html#182-202' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedconstant.ALIGN' class="associatedconstant hidden"><code>const <a href='../crossbeam_epoch/atomic/trait.Pointable.html#associatedconstant.ALIGN' class="constant"><b>ALIGN</b></a>: <a class="primitive" href="../std/primitive.usize.html">usize</a></code><a class='srclink' href='../src/crossbeam_epoch/atomic.rs.html#183' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>The alignment of pointer.</p>
</div><h4 id='associatedtype.Init' class="type"><code>type <a href='../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init' class="type">Init</a> = T</code></h4><div class='docblock'><p>The type for initializers.</p>
</div><h4 id='method.init' class="method hidden"><code>unsafe fn <a href='../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init' class='fnname'>init</a>(init: &lt;T as <a class="trait" href="../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a>&gt;::<a class="type" href="../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" title="type crossbeam_epoch::atomic::Pointable::Init">Init</a>) -&gt; <a class="primitive" href="../std/primitive.usize.html">usize</a></code><a class='srclink' href='../src/crossbeam_epoch/atomic.rs.html#187-189' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Initializes a with the given initializer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init">Read more</a></p>
</div><h4 id='method.deref-1' class="method hidden"><code>unsafe fn <a href='../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref' class='fnname'>deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="../std/primitive.reference.html">&amp;'a </a>T</code><a class='srclink' href='../src/crossbeam_epoch/atomic.rs.html#191-193' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref">Read more</a></p>
</div><h4 id='method.deref_mut-1' class="method hidden"><code>unsafe fn <a href='../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut' class='fnname'>deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="../std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="../std/primitive.reference.html">&amp;'a mut </a>T</code><a class='srclink' href='../src/crossbeam_epoch/atomic.rs.html#195-197' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably dereferences the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut">Read more</a></p>
</div><h4 id='method.drop-1' class="method hidden"><code>unsafe fn <a href='../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop' class='fnname'>drop</a>(ptr: <a class="primitive" href="../std/primitive.usize.html">usize</a>)</code><a class='srclink' href='../src/crossbeam_epoch/atomic.rs.html#199-201' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Drops the object pointed to by the given pointer. <a href="../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop">Read more</a></p>
</div></div><h3 id='impl-Same%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a>&lt;T&gt; for T</code><a href='#impl-Same%3CT%3E' class='anchor'></a><a class='srclink' href='../src/typenum/type_operators.rs.html#33-35' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Output' class="type"><code>type <a href='../typenum/type_operators/trait.Same.html#associatedtype.Output' class="type">Output</a> = T</code></h4><div class='docblock'><p>Should always be <code>Self</code></p>
</div></div><h3 id='impl-ToOwned' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="../alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-ToOwned' class='anchor'></a><a class='srclink' href='../src/alloc/borrow.rs.html#80-92' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Owned' class="type"><code>type <a href='../alloc/borrow/trait.ToOwned.html#associatedtype.Owned' class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id='method.to_owned' class="method hidden"><code>fn <a href='../alloc/borrow/trait.ToOwned.html#tymethod.to_owned' class='fnname'>to_owned</a>(&amp;self) -&gt; T</code><a class='srclink' href='../src/alloc/borrow.rs.html#85-87' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="../alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id='method.clone_into' class="method hidden"><code>fn <a href='../alloc/borrow/trait.ToOwned.html#method.clone_into' class='fnname'>clone_into</a>(&amp;self, target: <a class="primitive" href="../std/primitive.reference.html">&amp;mut </a>T)</code><a class='srclink' href='../src/alloc/borrow.rs.html#89-91' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="../alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='../src/core/convert/mod.rs.html#606-615' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code>type <a href='../core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="../core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code>fn <a href='../core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/convert/mod.rs.html#612-614' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="../core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='../src/core/convert/mod.rs.html#592-601' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code>type <a href='../core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code>fn <a href='../core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="../core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="../core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='../src/core/convert/mod.rs.html#598-600' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-VZip%3CV%3E' class='impl'><code class='in-band'>impl&lt;V, T&gt; <a class="trait" href="../ppv_lite86/types/trait.VZip.html" title="trait ppv_lite86::types::VZip">VZip</a>&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: <a class="trait" href="../ppv_lite86/types/trait.MultiLane.html" title="trait ppv_lite86::types::MultiLane">MultiLane</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-VZip%3CV%3E' class='anchor'></a><a class='srclink' href='../src/ppv_lite86/types.rs.html#211-219' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.vzip' class="method hidden"><code>fn <a href='../ppv_lite86/types/trait.VZip.html#tymethod.vzip' class='fnname'>vzip</a>(self) -&gt; V</code><a class='srclink' href='../src/ppv_lite86/types.rs.html#216-218' title='goto source code'>[src]</a></h4></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "style";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>